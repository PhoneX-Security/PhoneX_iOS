// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "PEXPbMessage_keyslots_draft.pb.h"
// @@protoc_insertion_point(imports)

@implementation PexpbMessageKeyslotsDraftRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [PexpbMessageKeyslotsDraftRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface PEXPbUserKey ()
@property UInt32 keySlotId;
@property (strong) NSData* key;
@property (strong) NSData* macKey;
@end

@implementation PEXPbUserKey

- (BOOL) hasKeySlotId {
  return !!hasKeySlotId_;
}
- (void) setHasKeySlotId:(BOOL) value_ {
  hasKeySlotId_ = !!value_;
}
@synthesize keySlotId;
- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) value_ {
  hasKey_ = !!value_;
}
@synthesize key;
- (BOOL) hasMacKey {
  return !!hasMacKey_;
}
- (void) setHasMacKey:(BOOL) value_ {
  hasMacKey_ = !!value_;
}
@synthesize macKey;
- (id) init {
  if ((self = [super init])) {
    self.keySlotId = 0;
    self.key = [NSData data];
    self.macKey = [NSData data];
  }
  return self;
}
static PEXPbUserKey* defaultPEXPbUserKeyInstance = nil;
+ (void) initialize {
  if (self == [PEXPbUserKey class]) {
    defaultPEXPbUserKeyInstance = [[PEXPbUserKey alloc] init];
  }
}
+ (PEXPbUserKey*) defaultInstance {
  return defaultPEXPbUserKeyInstance;
}
- (PEXPbUserKey*) defaultInstance {
  return defaultPEXPbUserKeyInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKeySlotId) {
    [output writeUInt32:1 value:self.keySlotId];
  }
  if (self.hasKey) {
    [output writeData:2 value:self.key];
  }
  if (self.hasMacKey) {
    [output writeData:3 value:self.macKey];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasKeySlotId) {
    size_ += computeUInt32Size(1, self.keySlotId);
  }
  if (self.hasKey) {
    size_ += computeDataSize(2, self.key);
  }
  if (self.hasMacKey) {
    size_ += computeDataSize(3, self.macKey);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbUserKey*) parseFromData:(NSData*) data {
  return (PEXPbUserKey*)[[[PEXPbUserKey builder] mergeFromData:data] build];
}
+ (PEXPbUserKey*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUserKey*)[[[PEXPbUserKey builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUserKey*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbUserKey*)[[[PEXPbUserKey builder] mergeFromInputStream:input] build];
}
+ (PEXPbUserKey*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUserKey*)[[[PEXPbUserKey builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUserKey*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbUserKey*)[[[PEXPbUserKey builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbUserKey*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUserKey*)[[[PEXPbUserKey builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUserKeyBuilder*) builder {
  return [[PEXPbUserKeyBuilder alloc] init];
}
+ (PEXPbUserKeyBuilder*) builderWithPrototype:(PEXPbUserKey*) prototype {
  return [[PEXPbUserKey builder] mergeFrom:prototype];
}
- (PEXPbUserKeyBuilder*) builder {
  return [PEXPbUserKey builder];
}
- (PEXPbUserKeyBuilder*) toBuilder {
  return [PEXPbUserKey builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasKeySlotId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"keySlotId", [NSNumber numberWithInteger:self.keySlotId]];
  }
  if (self.hasKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"key", self.key];
  }
  if (self.hasMacKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"macKey", self.macKey];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbUserKey class]]) {
    return NO;
  }
  PEXPbUserKey *otherMessage = other;
  return
      self.hasKeySlotId == otherMessage.hasKeySlotId &&
      (!self.hasKeySlotId || self.keySlotId == otherMessage.keySlotId) &&
      self.hasKey == otherMessage.hasKey &&
      (!self.hasKey || [self.key isEqual:otherMessage.key]) &&
      self.hasMacKey == otherMessage.hasMacKey &&
      (!self.hasMacKey || [self.macKey isEqual:otherMessage.macKey]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasKeySlotId) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.keySlotId] hash];
  }
  if (self.hasKey) {
    hashCode = hashCode * 31 + [self.key hash];
  }
  if (self.hasMacKey) {
    hashCode = hashCode * 31 + [self.macKey hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbUserKeyBuilder()
@property (strong) PEXPbUserKey* result;
@end

@implementation PEXPbUserKeyBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbUserKey alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbUserKeyBuilder*) clear {
  self.result = [[PEXPbUserKey alloc] init];
  return self;
}
- (PEXPbUserKeyBuilder*) clone {
  return [PEXPbUserKey builderWithPrototype:result];
}
- (PEXPbUserKey*) defaultInstance {
  return [PEXPbUserKey defaultInstance];
}
- (PEXPbUserKey*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbUserKey*) buildPartial {
  PEXPbUserKey* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbUserKeyBuilder*) mergeFrom:(PEXPbUserKey*) other {
  if (other == [PEXPbUserKey defaultInstance]) {
    return self;
  }
  if (other.hasKeySlotId) {
    [self setKeySlotId:other.keySlotId];
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  if (other.hasMacKey) {
    [self setMacKey:other.macKey];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbUserKeyBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbUserKeyBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setKeySlotId:[input readUInt32]];
        break;
      }
      case 18: {
        [self setKey:[input readData]];
        break;
      }
      case 26: {
        [self setMacKey:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasKeySlotId {
  return result.hasKeySlotId;
}
- (UInt32) keySlotId {
  return result.keySlotId;
}
- (PEXPbUserKeyBuilder*) setKeySlotId:(UInt32) value {
  result.hasKeySlotId = YES;
  result.keySlotId = value;
  return self;
}
- (PEXPbUserKeyBuilder*) clearKeySlotId {
  result.hasKeySlotId = NO;
  result.keySlotId = 0;
  return self;
}
- (BOOL) hasKey {
  return result.hasKey;
}
- (NSData*) key {
  return result.key;
}
- (PEXPbUserKeyBuilder*) setKey:(NSData*) value {
  result.hasKey = YES;
  result.key = value;
  return self;
}
- (PEXPbUserKeyBuilder*) clearKey {
  result.hasKey = NO;
  result.key = [NSData data];
  return self;
}
- (BOOL) hasMacKey {
  return result.hasMacKey;
}
- (NSData*) macKey {
  return result.macKey;
}
- (PEXPbUserKeyBuilder*) setMacKey:(NSData*) value {
  result.hasMacKey = YES;
  result.macKey = value;
  return self;
}
- (PEXPbUserKeyBuilder*) clearMacKey {
  result.hasMacKey = NO;
  result.macKey = [NSData data];
  return self;
}
@end

@interface PEXPbMsgKeyPart ()
@property UInt32 version;
@property PEXPbMsgKeyPartPEXPbKeyType type;
@property (strong) NSString* destUser;
@property (strong) NSData* aCiphertext;
@property (strong) NSData* sIv;
@property (strong) NSData* sCiphertext;
@property (strong) NSData* mac;
@end

@implementation PEXPbMsgKeyPart

- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasDestUser {
  return !!hasDestUser_;
}
- (void) setHasDestUser:(BOOL) value_ {
  hasDestUser_ = !!value_;
}
@synthesize destUser;
- (BOOL) hasACiphertext {
  return !!hasACiphertext_;
}
- (void) setHasACiphertext:(BOOL) value_ {
  hasACiphertext_ = !!value_;
}
@synthesize aCiphertext;
- (BOOL) hasSIv {
  return !!hasSIv_;
}
- (void) setHasSIv:(BOOL) value_ {
  hasSIv_ = !!value_;
}
@synthesize sIv;
- (BOOL) hasSCiphertext {
  return !!hasSCiphertext_;
}
- (void) setHasSCiphertext:(BOOL) value_ {
  hasSCiphertext_ = !!value_;
}
@synthesize sCiphertext;
- (BOOL) hasMac {
  return !!hasMac_;
}
- (void) setHasMac:(BOOL) value_ {
  hasMac_ = !!value_;
}
@synthesize mac;
- (id) init {
  if ((self = [super init])) {
    self.version = 1;
    self.type = PEXPbMsgKeyPartPEXPbKeyTypePubenc;
    self.destUser = @"";
    self.aCiphertext = [NSData data];
    self.sIv = [NSData data];
    self.sCiphertext = [NSData data];
    self.mac = [NSData data];
  }
  return self;
}
static PEXPbMsgKeyPart* defaultPEXPbMsgKeyPartInstance = nil;
+ (void) initialize {
  if (self == [PEXPbMsgKeyPart class]) {
    defaultPEXPbMsgKeyPartInstance = [[PEXPbMsgKeyPart alloc] init];
  }
}
+ (PEXPbMsgKeyPart*) defaultInstance {
  return defaultPEXPbMsgKeyPartInstance;
}
- (PEXPbMsgKeyPart*) defaultInstance {
  return defaultPEXPbMsgKeyPartInstance;
}
- (BOOL) isInitialized {
  if (!self.hasACiphertext) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasVersion) {
    [output writeUInt32:1 value:self.version];
  }
  if (self.hasType) {
    [output writeEnum:2 value:self.type];
  }
  if (self.hasDestUser) {
    [output writeString:3 value:self.destUser];
  }
  if (self.hasACiphertext) {
    [output writeData:10 value:self.aCiphertext];
  }
  if (self.hasSIv) {
    [output writeData:11 value:self.sIv];
  }
  if (self.hasSCiphertext) {
    [output writeData:12 value:self.sCiphertext];
  }
  if (self.hasMac) {
    [output writeData:20 value:self.mac];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasVersion) {
    size_ += computeUInt32Size(1, self.version);
  }
  if (self.hasType) {
    size_ += computeEnumSize(2, self.type);
  }
  if (self.hasDestUser) {
    size_ += computeStringSize(3, self.destUser);
  }
  if (self.hasACiphertext) {
    size_ += computeDataSize(10, self.aCiphertext);
  }
  if (self.hasSIv) {
    size_ += computeDataSize(11, self.sIv);
  }
  if (self.hasSCiphertext) {
    size_ += computeDataSize(12, self.sCiphertext);
  }
  if (self.hasMac) {
    size_ += computeDataSize(20, self.mac);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbMsgKeyPart*) parseFromData:(NSData*) data {
  return (PEXPbMsgKeyPart*)[[[PEXPbMsgKeyPart builder] mergeFromData:data] build];
}
+ (PEXPbMsgKeyPart*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMsgKeyPart*)[[[PEXPbMsgKeyPart builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMsgKeyPart*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbMsgKeyPart*)[[[PEXPbMsgKeyPart builder] mergeFromInputStream:input] build];
}
+ (PEXPbMsgKeyPart*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMsgKeyPart*)[[[PEXPbMsgKeyPart builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMsgKeyPart*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbMsgKeyPart*)[[[PEXPbMsgKeyPart builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbMsgKeyPart*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMsgKeyPart*)[[[PEXPbMsgKeyPart builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMsgKeyPartBuilder*) builder {
  return [[PEXPbMsgKeyPartBuilder alloc] init];
}
+ (PEXPbMsgKeyPartBuilder*) builderWithPrototype:(PEXPbMsgKeyPart*) prototype {
  return [[PEXPbMsgKeyPart builder] mergeFrom:prototype];
}
- (PEXPbMsgKeyPartBuilder*) builder {
  return [PEXPbMsgKeyPart builder];
}
- (PEXPbMsgKeyPartBuilder*) toBuilder {
  return [PEXPbMsgKeyPart builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  if (self.hasType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"type", [NSNumber numberWithInteger:self.type]];
  }
  if (self.hasDestUser) {
    [output appendFormat:@"%@%@: %@\n", indent, @"destUser", self.destUser];
  }
  if (self.hasACiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"aCiphertext", self.aCiphertext];
  }
  if (self.hasSIv) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sIv", self.sIv];
  }
  if (self.hasSCiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sCiphertext", self.sCiphertext];
  }
  if (self.hasMac) {
    [output appendFormat:@"%@%@: %@\n", indent, @"mac", self.mac];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbMsgKeyPart class]]) {
    return NO;
  }
  PEXPbMsgKeyPart *otherMessage = other;
  return
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasDestUser == otherMessage.hasDestUser &&
      (!self.hasDestUser || [self.destUser isEqual:otherMessage.destUser]) &&
      self.hasACiphertext == otherMessage.hasACiphertext &&
      (!self.hasACiphertext || [self.aCiphertext isEqual:otherMessage.aCiphertext]) &&
      self.hasSIv == otherMessage.hasSIv &&
      (!self.hasSIv || [self.sIv isEqual:otherMessage.sIv]) &&
      self.hasSCiphertext == otherMessage.hasSCiphertext &&
      (!self.hasSCiphertext || [self.sCiphertext isEqual:otherMessage.sCiphertext]) &&
      self.hasMac == otherMessage.hasMac &&
      (!self.hasMac || [self.mac isEqual:otherMessage.mac]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasDestUser) {
    hashCode = hashCode * 31 + [self.destUser hash];
  }
  if (self.hasACiphertext) {
    hashCode = hashCode * 31 + [self.aCiphertext hash];
  }
  if (self.hasSIv) {
    hashCode = hashCode * 31 + [self.sIv hash];
  }
  if (self.hasSCiphertext) {
    hashCode = hashCode * 31 + [self.sCiphertext hash];
  }
  if (self.hasMac) {
    hashCode = hashCode * 31 + [self.mac hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL PEXPbMsgKeyPartPEXPbKeyTypeIsValidValue(PEXPbMsgKeyPartPEXPbKeyType value) {
  switch (value) {
    case PEXPbMsgKeyPartPEXPbKeyTypePubenc:
    case PEXPbMsgKeyPartPEXPbKeyTypeDhkey:
      return YES;
    default:
      return NO;
  }
}
@interface PEXPbMsgKeyPartBuilder()
@property (strong) PEXPbMsgKeyPart* result;
@end

@implementation PEXPbMsgKeyPartBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbMsgKeyPart alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbMsgKeyPartBuilder*) clear {
  self.result = [[PEXPbMsgKeyPart alloc] init];
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clone {
  return [PEXPbMsgKeyPart builderWithPrototype:result];
}
- (PEXPbMsgKeyPart*) defaultInstance {
  return [PEXPbMsgKeyPart defaultInstance];
}
- (PEXPbMsgKeyPart*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbMsgKeyPart*) buildPartial {
  PEXPbMsgKeyPart* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbMsgKeyPartBuilder*) mergeFrom:(PEXPbMsgKeyPart*) other {
  if (other == [PEXPbMsgKeyPart defaultInstance]) {
    return self;
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasDestUser) {
    [self setDestUser:other.destUser];
  }
  if (other.hasACiphertext) {
    [self setACiphertext:other.aCiphertext];
  }
  if (other.hasSIv) {
    [self setSIv:other.sIv];
  }
  if (other.hasSCiphertext) {
    [self setSCiphertext:other.sCiphertext];
  }
  if (other.hasMac) {
    [self setMac:other.mac];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbMsgKeyPartBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbMsgKeyPartBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setVersion:[input readUInt32]];
        break;
      }
      case 16: {
        PEXPbMsgKeyPartPEXPbKeyType value = (PEXPbMsgKeyPartPEXPbKeyType)[input readEnum];
        if (PEXPbMsgKeyPartPEXPbKeyTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:2 value:value];
        }
        break;
      }
      case 26: {
        [self setDestUser:[input readString]];
        break;
      }
      case 82: {
        [self setACiphertext:[input readData]];
        break;
      }
      case 90: {
        [self setSIv:[input readData]];
        break;
      }
      case 98: {
        [self setSCiphertext:[input readData]];
        break;
      }
      case 162: {
        [self setMac:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (UInt32) version {
  return result.version;
}
- (PEXPbMsgKeyPartBuilder*) setVersion:(UInt32) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearVersion {
  result.hasVersion = NO;
  result.version = 1;
  return self;
}
- (BOOL) hasType {
  return result.hasType;
}
- (PEXPbMsgKeyPartPEXPbKeyType) type {
  return result.type;
}
- (PEXPbMsgKeyPartBuilder*) setType:(PEXPbMsgKeyPartPEXPbKeyType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearType {
  result.hasType = NO;
  result.type = PEXPbMsgKeyPartPEXPbKeyTypePubenc;
  return self;
}
- (BOOL) hasDestUser {
  return result.hasDestUser;
}
- (NSString*) destUser {
  return result.destUser;
}
- (PEXPbMsgKeyPartBuilder*) setDestUser:(NSString*) value {
  result.hasDestUser = YES;
  result.destUser = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearDestUser {
  result.hasDestUser = NO;
  result.destUser = @"";
  return self;
}
- (BOOL) hasACiphertext {
  return result.hasACiphertext;
}
- (NSData*) aCiphertext {
  return result.aCiphertext;
}
- (PEXPbMsgKeyPartBuilder*) setACiphertext:(NSData*) value {
  result.hasACiphertext = YES;
  result.aCiphertext = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearACiphertext {
  result.hasACiphertext = NO;
  result.aCiphertext = [NSData data];
  return self;
}
- (BOOL) hasSIv {
  return result.hasSIv;
}
- (NSData*) sIv {
  return result.sIv;
}
- (PEXPbMsgKeyPartBuilder*) setSIv:(NSData*) value {
  result.hasSIv = YES;
  result.sIv = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearSIv {
  result.hasSIv = NO;
  result.sIv = [NSData data];
  return self;
}
- (BOOL) hasSCiphertext {
  return result.hasSCiphertext;
}
- (NSData*) sCiphertext {
  return result.sCiphertext;
}
- (PEXPbMsgKeyPartBuilder*) setSCiphertext:(NSData*) value {
  result.hasSCiphertext = YES;
  result.sCiphertext = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearSCiphertext {
  result.hasSCiphertext = NO;
  result.sCiphertext = [NSData data];
  return self;
}
- (BOOL) hasMac {
  return result.hasMac;
}
- (NSData*) mac {
  return result.mac;
}
- (PEXPbMsgKeyPartBuilder*) setMac:(NSData*) value {
  result.hasMac = YES;
  result.mac = value;
  return self;
}
- (PEXPbMsgKeyPartBuilder*) clearMac {
  result.hasMac = NO;
  result.mac = [NSData data];
  return self;
}
@end

@interface PEXPbKeySlot ()
@property PEXPbKeySlotPEXPbKeySlotEncryption encType;
@property (strong) NSData* iv;
@property (strong) NSData* encKey;
@property (strong) NSData* mac;
@end

@implementation PEXPbKeySlot

- (BOOL) hasEncType {
  return !!hasEncType_;
}
- (void) setHasEncType:(BOOL) value_ {
  hasEncType_ = !!value_;
}
@synthesize encType;
- (BOOL) hasIv {
  return !!hasIv_;
}
- (void) setHasIv:(BOOL) value_ {
  hasIv_ = !!value_;
}
@synthesize iv;
- (BOOL) hasEncKey {
  return !!hasEncKey_;
}
- (void) setHasEncKey:(BOOL) value_ {
  hasEncKey_ = !!value_;
}
@synthesize encKey;
- (BOOL) hasMac {
  return !!hasMac_;
}
- (void) setHasMac:(BOOL) value_ {
  hasMac_ = !!value_;
}
@synthesize mac;
- (id) init {
  if ((self = [super init])) {
    self.encType = PEXPbKeySlotPEXPbKeySlotEncryptionAes256Gcm;
    self.iv = [NSData data];
    self.encKey = [NSData data];
    self.mac = [NSData data];
  }
  return self;
}
static PEXPbKeySlot* defaultPEXPbKeySlotInstance = nil;
+ (void) initialize {
  if (self == [PEXPbKeySlot class]) {
    defaultPEXPbKeySlotInstance = [[PEXPbKeySlot alloc] init];
  }
}
+ (PEXPbKeySlot*) defaultInstance {
  return defaultPEXPbKeySlotInstance;
}
- (PEXPbKeySlot*) defaultInstance {
  return defaultPEXPbKeySlotInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasEncType) {
    [output writeEnum:1 value:self.encType];
  }
  if (self.hasIv) {
    [output writeData:2 value:self.iv];
  }
  if (self.hasEncKey) {
    [output writeData:3 value:self.encKey];
  }
  if (self.hasMac) {
    [output writeData:4 value:self.mac];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasEncType) {
    size_ += computeEnumSize(1, self.encType);
  }
  if (self.hasIv) {
    size_ += computeDataSize(2, self.iv);
  }
  if (self.hasEncKey) {
    size_ += computeDataSize(3, self.encKey);
  }
  if (self.hasMac) {
    size_ += computeDataSize(4, self.mac);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbKeySlot*) parseFromData:(NSData*) data {
  return (PEXPbKeySlot*)[[[PEXPbKeySlot builder] mergeFromData:data] build];
}
+ (PEXPbKeySlot*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbKeySlot*)[[[PEXPbKeySlot builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbKeySlot*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbKeySlot*)[[[PEXPbKeySlot builder] mergeFromInputStream:input] build];
}
+ (PEXPbKeySlot*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbKeySlot*)[[[PEXPbKeySlot builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbKeySlot*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbKeySlot*)[[[PEXPbKeySlot builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbKeySlot*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbKeySlot*)[[[PEXPbKeySlot builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbKeySlotBuilder*) builder {
  return [[PEXPbKeySlotBuilder alloc] init];
}
+ (PEXPbKeySlotBuilder*) builderWithPrototype:(PEXPbKeySlot*) prototype {
  return [[PEXPbKeySlot builder] mergeFrom:prototype];
}
- (PEXPbKeySlotBuilder*) builder {
  return [PEXPbKeySlot builder];
}
- (PEXPbKeySlotBuilder*) toBuilder {
  return [PEXPbKeySlot builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasEncType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"encType", [NSNumber numberWithInteger:self.encType]];
  }
  if (self.hasIv) {
    [output appendFormat:@"%@%@: %@\n", indent, @"iv", self.iv];
  }
  if (self.hasEncKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"encKey", self.encKey];
  }
  if (self.hasMac) {
    [output appendFormat:@"%@%@: %@\n", indent, @"mac", self.mac];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbKeySlot class]]) {
    return NO;
  }
  PEXPbKeySlot *otherMessage = other;
  return
      self.hasEncType == otherMessage.hasEncType &&
      (!self.hasEncType || self.encType == otherMessage.encType) &&
      self.hasIv == otherMessage.hasIv &&
      (!self.hasIv || [self.iv isEqual:otherMessage.iv]) &&
      self.hasEncKey == otherMessage.hasEncKey &&
      (!self.hasEncKey || [self.encKey isEqual:otherMessage.encKey]) &&
      self.hasMac == otherMessage.hasMac &&
      (!self.hasMac || [self.mac isEqual:otherMessage.mac]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasEncType) {
    hashCode = hashCode * 31 + self.encType;
  }
  if (self.hasIv) {
    hashCode = hashCode * 31 + [self.iv hash];
  }
  if (self.hasEncKey) {
    hashCode = hashCode * 31 + [self.encKey hash];
  }
  if (self.hasMac) {
    hashCode = hashCode * 31 + [self.mac hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL PEXPbKeySlotPEXPbKeySlotEncryptionIsValidValue(PEXPbKeySlotPEXPbKeySlotEncryption value) {
  switch (value) {
    case PEXPbKeySlotPEXPbKeySlotEncryptionAes256Cbc:
    case PEXPbKeySlotPEXPbKeySlotEncryptionAes256Cbcmac:
    case PEXPbKeySlotPEXPbKeySlotEncryptionAes256Gcm:
      return YES;
    default:
      return NO;
  }
}
@interface PEXPbKeySlotBuilder()
@property (strong) PEXPbKeySlot* result;
@end

@implementation PEXPbKeySlotBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbKeySlot alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbKeySlotBuilder*) clear {
  self.result = [[PEXPbKeySlot alloc] init];
  return self;
}
- (PEXPbKeySlotBuilder*) clone {
  return [PEXPbKeySlot builderWithPrototype:result];
}
- (PEXPbKeySlot*) defaultInstance {
  return [PEXPbKeySlot defaultInstance];
}
- (PEXPbKeySlot*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbKeySlot*) buildPartial {
  PEXPbKeySlot* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbKeySlotBuilder*) mergeFrom:(PEXPbKeySlot*) other {
  if (other == [PEXPbKeySlot defaultInstance]) {
    return self;
  }
  if (other.hasEncType) {
    [self setEncType:other.encType];
  }
  if (other.hasIv) {
    [self setIv:other.iv];
  }
  if (other.hasEncKey) {
    [self setEncKey:other.encKey];
  }
  if (other.hasMac) {
    [self setMac:other.mac];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbKeySlotBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbKeySlotBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        PEXPbKeySlotPEXPbKeySlotEncryption value = (PEXPbKeySlotPEXPbKeySlotEncryption)[input readEnum];
        if (PEXPbKeySlotPEXPbKeySlotEncryptionIsValidValue(value)) {
          [self setEncType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        [self setIv:[input readData]];
        break;
      }
      case 26: {
        [self setEncKey:[input readData]];
        break;
      }
      case 34: {
        [self setMac:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasEncType {
  return result.hasEncType;
}
- (PEXPbKeySlotPEXPbKeySlotEncryption) encType {
  return result.encType;
}
- (PEXPbKeySlotBuilder*) setEncType:(PEXPbKeySlotPEXPbKeySlotEncryption) value {
  result.hasEncType = YES;
  result.encType = value;
  return self;
}
- (PEXPbKeySlotBuilder*) clearEncType {
  result.hasEncType = NO;
  result.encType = PEXPbKeySlotPEXPbKeySlotEncryptionAes256Gcm;
  return self;
}
- (BOOL) hasIv {
  return result.hasIv;
}
- (NSData*) iv {
  return result.iv;
}
- (PEXPbKeySlotBuilder*) setIv:(NSData*) value {
  result.hasIv = YES;
  result.iv = value;
  return self;
}
- (PEXPbKeySlotBuilder*) clearIv {
  result.hasIv = NO;
  result.iv = [NSData data];
  return self;
}
- (BOOL) hasEncKey {
  return result.hasEncKey;
}
- (NSData*) encKey {
  return result.encKey;
}
- (PEXPbKeySlotBuilder*) setEncKey:(NSData*) value {
  result.hasEncKey = YES;
  result.encKey = value;
  return self;
}
- (PEXPbKeySlotBuilder*) clearEncKey {
  result.hasEncKey = NO;
  result.encKey = [NSData data];
  return self;
}
- (BOOL) hasMac {
  return result.hasMac;
}
- (NSData*) mac {
  return result.mac;
}
- (PEXPbKeySlotBuilder*) setMac:(NSData*) value {
  result.hasMac = YES;
  result.mac = value;
  return self;
}
- (PEXPbKeySlotBuilder*) clearMac {
  result.hasMac = NO;
  result.mac = [NSData data];
  return self;
}
@end

@interface PEXPbEncryptedMessage ()
@property UInt32 version;
@property (strong) NSMutableArray * keysArray;
@property (strong) NSMutableArray * keySlotsArray;
@property (strong) NSData* aCiphertext;
@property (strong) NSData* sIv;
@property (strong) NSData* sCiphertext;
@end

@implementation PEXPbEncryptedMessage

- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
@synthesize keysArray;
@dynamic keys;
@synthesize keySlotsArray;
@dynamic keySlots;
- (BOOL) hasACiphertext {
  return !!hasACiphertext_;
}
- (void) setHasACiphertext:(BOOL) value_ {
  hasACiphertext_ = !!value_;
}
@synthesize aCiphertext;
- (BOOL) hasSIv {
  return !!hasSIv_;
}
- (void) setHasSIv:(BOOL) value_ {
  hasSIv_ = !!value_;
}
@synthesize sIv;
- (BOOL) hasSCiphertext {
  return !!hasSCiphertext_;
}
- (void) setHasSCiphertext:(BOOL) value_ {
  hasSCiphertext_ = !!value_;
}
@synthesize sCiphertext;
- (id) init {
  if ((self = [super init])) {
    self.version = 1;
    self.aCiphertext = [NSData data];
    self.sIv = [NSData data];
    self.sCiphertext = [NSData data];
  }
  return self;
}
static PEXPbEncryptedMessage* defaultPEXPbEncryptedMessageInstance = nil;
+ (void) initialize {
  if (self == [PEXPbEncryptedMessage class]) {
    defaultPEXPbEncryptedMessageInstance = [[PEXPbEncryptedMessage alloc] init];
  }
}
+ (PEXPbEncryptedMessage*) defaultInstance {
  return defaultPEXPbEncryptedMessageInstance;
}
- (PEXPbEncryptedMessage*) defaultInstance {
  return defaultPEXPbEncryptedMessageInstance;
}
- (NSArray *)keys {
  return keysArray;
}
- (PEXPbMsgKeyPart*)keysAtIndex:(NSUInteger)index {
  return [keysArray objectAtIndex:index];
}
- (NSArray *)keySlots {
  return keySlotsArray;
}
- (PEXPbKeySlot*)keySlotsAtIndex:(NSUInteger)index {
  return [keySlotsArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  if (!self.hasACiphertext) {
    return NO;
  }
  __block BOOL isInitkeys = YES;
   [self.keys enumerateObjectsUsingBlock:^(PEXPbMsgKeyPart *element, NSUInteger idx, BOOL *stop) {
    if (!element.isInitialized) {
      isInitkeys = NO;
      *stop = YES;
    }
  }];
  if (!isInitkeys) return isInitkeys;
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasVersion) {
    [output writeUInt32:1 value:self.version];
  }
  [self.keysArray enumerateObjectsUsingBlock:^(PEXPbMsgKeyPart *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:2 value:element];
  }];
  [self.keySlotsArray enumerateObjectsUsingBlock:^(PEXPbKeySlot *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:3 value:element];
  }];
  if (self.hasACiphertext) {
    [output writeData:10 value:self.aCiphertext];
  }
  if (self.hasSIv) {
    [output writeData:11 value:self.sIv];
  }
  if (self.hasSCiphertext) {
    [output writeData:12 value:self.sCiphertext];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasVersion) {
    size_ += computeUInt32Size(1, self.version);
  }
  [self.keysArray enumerateObjectsUsingBlock:^(PEXPbMsgKeyPart *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(2, element);
  }];
  [self.keySlotsArray enumerateObjectsUsingBlock:^(PEXPbKeySlot *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(3, element);
  }];
  if (self.hasACiphertext) {
    size_ += computeDataSize(10, self.aCiphertext);
  }
  if (self.hasSIv) {
    size_ += computeDataSize(11, self.sIv);
  }
  if (self.hasSCiphertext) {
    size_ += computeDataSize(12, self.sCiphertext);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbEncryptedMessage*) parseFromData:(NSData*) data {
  return (PEXPbEncryptedMessage*)[[[PEXPbEncryptedMessage builder] mergeFromData:data] build];
}
+ (PEXPbEncryptedMessage*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbEncryptedMessage*)[[[PEXPbEncryptedMessage builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbEncryptedMessage*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbEncryptedMessage*)[[[PEXPbEncryptedMessage builder] mergeFromInputStream:input] build];
}
+ (PEXPbEncryptedMessage*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbEncryptedMessage*)[[[PEXPbEncryptedMessage builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbEncryptedMessage*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbEncryptedMessage*)[[[PEXPbEncryptedMessage builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbEncryptedMessage*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbEncryptedMessage*)[[[PEXPbEncryptedMessage builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbEncryptedMessageBuilder*) builder {
  return [[PEXPbEncryptedMessageBuilder alloc] init];
}
+ (PEXPbEncryptedMessageBuilder*) builderWithPrototype:(PEXPbEncryptedMessage*) prototype {
  return [[PEXPbEncryptedMessage builder] mergeFrom:prototype];
}
- (PEXPbEncryptedMessageBuilder*) builder {
  return [PEXPbEncryptedMessage builder];
}
- (PEXPbEncryptedMessageBuilder*) toBuilder {
  return [PEXPbEncryptedMessage builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  [self.keysArray enumerateObjectsUsingBlock:^(PEXPbMsgKeyPart *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"keys"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.keySlotsArray enumerateObjectsUsingBlock:^(PEXPbKeySlot *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"keySlots"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  if (self.hasACiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"aCiphertext", self.aCiphertext];
  }
  if (self.hasSIv) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sIv", self.sIv];
  }
  if (self.hasSCiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sCiphertext", self.sCiphertext];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbEncryptedMessage class]]) {
    return NO;
  }
  PEXPbEncryptedMessage *otherMessage = other;
  return
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      [self.keysArray isEqualToArray:otherMessage.keysArray] &&
      [self.keySlotsArray isEqualToArray:otherMessage.keySlotsArray] &&
      self.hasACiphertext == otherMessage.hasACiphertext &&
      (!self.hasACiphertext || [self.aCiphertext isEqual:otherMessage.aCiphertext]) &&
      self.hasSIv == otherMessage.hasSIv &&
      (!self.hasSIv || [self.sIv isEqual:otherMessage.sIv]) &&
      self.hasSCiphertext == otherMessage.hasSCiphertext &&
      (!self.hasSCiphertext || [self.sCiphertext isEqual:otherMessage.sCiphertext]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  [self.keysArray enumerateObjectsUsingBlock:^(PEXPbMsgKeyPart *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  [self.keySlotsArray enumerateObjectsUsingBlock:^(PEXPbKeySlot *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  if (self.hasACiphertext) {
    hashCode = hashCode * 31 + [self.aCiphertext hash];
  }
  if (self.hasSIv) {
    hashCode = hashCode * 31 + [self.sIv hash];
  }
  if (self.hasSCiphertext) {
    hashCode = hashCode * 31 + [self.sCiphertext hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbEncryptedMessageBuilder()
@property (strong) PEXPbEncryptedMessage* result;
@end

@implementation PEXPbEncryptedMessageBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbEncryptedMessage alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbEncryptedMessageBuilder*) clear {
  self.result = [[PEXPbEncryptedMessage alloc] init];
  return self;
}
- (PEXPbEncryptedMessageBuilder*) clone {
  return [PEXPbEncryptedMessage builderWithPrototype:result];
}
- (PEXPbEncryptedMessage*) defaultInstance {
  return [PEXPbEncryptedMessage defaultInstance];
}
- (PEXPbEncryptedMessage*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbEncryptedMessage*) buildPartial {
  PEXPbEncryptedMessage* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbEncryptedMessageBuilder*) mergeFrom:(PEXPbEncryptedMessage*) other {
  if (other == [PEXPbEncryptedMessage defaultInstance]) {
    return self;
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.keysArray.count > 0) {
    if (result.keysArray == nil) {
      result.keysArray = [[NSMutableArray alloc] initWithArray:other.keysArray];
    } else {
      [result.keysArray addObjectsFromArray:other.keysArray];
    }
  }
  if (other.keySlotsArray.count > 0) {
    if (result.keySlotsArray == nil) {
      result.keySlotsArray = [[NSMutableArray alloc] initWithArray:other.keySlotsArray];
    } else {
      [result.keySlotsArray addObjectsFromArray:other.keySlotsArray];
    }
  }
  if (other.hasACiphertext) {
    [self setACiphertext:other.aCiphertext];
  }
  if (other.hasSIv) {
    [self setSIv:other.sIv];
  }
  if (other.hasSCiphertext) {
    [self setSCiphertext:other.sCiphertext];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbEncryptedMessageBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbEncryptedMessageBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setVersion:[input readUInt32]];
        break;
      }
      case 18: {
        PEXPbMsgKeyPartBuilder* subBuilder = [PEXPbMsgKeyPart builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addKeys:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        PEXPbKeySlotBuilder* subBuilder = [PEXPbKeySlot builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addKeySlots:[subBuilder buildPartial]];
        break;
      }
      case 82: {
        [self setACiphertext:[input readData]];
        break;
      }
      case 90: {
        [self setSIv:[input readData]];
        break;
      }
      case 98: {
        [self setSCiphertext:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (UInt32) version {
  return result.version;
}
- (PEXPbEncryptedMessageBuilder*) setVersion:(UInt32) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (PEXPbEncryptedMessageBuilder*) clearVersion {
  result.hasVersion = NO;
  result.version = 1;
  return self;
}
- (NSMutableArray *)keys {
  return result.keysArray;
}
- (PEXPbMsgKeyPart*)keysAtIndex:(NSUInteger)index {
  return [result keysAtIndex:index];
}
- (PEXPbEncryptedMessageBuilder *)addKeys:(PEXPbMsgKeyPart*)value {
  if (result.keysArray == nil) {
    result.keysArray = [[NSMutableArray alloc]init];
  }
  [result.keysArray addObject:value];
  return self;
}
- (PEXPbEncryptedMessageBuilder *)setKeysArray:(NSArray *)array {
  result.keysArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (PEXPbEncryptedMessageBuilder *)clearKeys {
  result.keysArray = nil;
  return self;
}
- (NSMutableArray *)keySlots {
  return result.keySlotsArray;
}
- (PEXPbKeySlot*)keySlotsAtIndex:(NSUInteger)index {
  return [result keySlotsAtIndex:index];
}
- (PEXPbEncryptedMessageBuilder *)addKeySlots:(PEXPbKeySlot*)value {
  if (result.keySlotsArray == nil) {
    result.keySlotsArray = [[NSMutableArray alloc]init];
  }
  [result.keySlotsArray addObject:value];
  return self;
}
- (PEXPbEncryptedMessageBuilder *)setKeySlotsArray:(NSArray *)array {
  result.keySlotsArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (PEXPbEncryptedMessageBuilder *)clearKeySlots {
  result.keySlotsArray = nil;
  return self;
}
- (BOOL) hasACiphertext {
  return result.hasACiphertext;
}
- (NSData*) aCiphertext {
  return result.aCiphertext;
}
- (PEXPbEncryptedMessageBuilder*) setACiphertext:(NSData*) value {
  result.hasACiphertext = YES;
  result.aCiphertext = value;
  return self;
}
- (PEXPbEncryptedMessageBuilder*) clearACiphertext {
  result.hasACiphertext = NO;
  result.aCiphertext = [NSData data];
  return self;
}
- (BOOL) hasSIv {
  return result.hasSIv;
}
- (NSData*) sIv {
  return result.sIv;
}
- (PEXPbEncryptedMessageBuilder*) setSIv:(NSData*) value {
  result.hasSIv = YES;
  result.sIv = value;
  return self;
}
- (PEXPbEncryptedMessageBuilder*) clearSIv {
  result.hasSIv = NO;
  result.sIv = [NSData data];
  return self;
}
- (BOOL) hasSCiphertext {
  return result.hasSCiphertext;
}
- (NSData*) sCiphertext {
  return result.sCiphertext;
}
- (PEXPbEncryptedMessageBuilder*) setSCiphertext:(NSData*) value {
  result.hasSCiphertext = YES;
  result.sCiphertext = value;
  return self;
}
- (PEXPbEncryptedMessageBuilder*) clearSCiphertext {
  result.hasSCiphertext = NO;
  result.sCiphertext = [NSData data];
  return self;
}
@end


// @@protoc_insertion_point(global_scope)
