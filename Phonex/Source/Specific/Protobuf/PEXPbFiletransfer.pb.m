// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "PEXPbFiletransfer.pb.h"
// @@protoc_insertion_point(imports)

@implementation PexpbFiletransferRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [PexpbFiletransferRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface PEXPbHybridEncryption ()
@property SInt32 version;
@property (strong) NSData* aCiphertext;
@property (strong) NSData* iv;
@property (strong) NSData* sCiphertext;
@end

@implementation PEXPbHybridEncryption

- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
- (BOOL) hasACiphertext {
  return !!hasACiphertext_;
}
- (void) setHasACiphertext:(BOOL) value_ {
  hasACiphertext_ = !!value_;
}
@synthesize aCiphertext;
- (BOOL) hasIv {
  return !!hasIv_;
}
- (void) setHasIv:(BOOL) value_ {
  hasIv_ = !!value_;
}
@synthesize iv;
- (BOOL) hasSCiphertext {
  return !!hasSCiphertext_;
}
- (void) setHasSCiphertext:(BOOL) value_ {
  hasSCiphertext_ = !!value_;
}
@synthesize sCiphertext;
- (id) init {
  if ((self = [super init])) {
    self.version = 1;
    self.aCiphertext = [NSData data];
    self.iv = [NSData data];
    self.sCiphertext = [NSData data];
  }
  return self;
}
static PEXPbHybridEncryption* defaultPEXPbHybridEncryptionInstance = nil;
+ (void) initialize {
  if (self == [PEXPbHybridEncryption class]) {
    defaultPEXPbHybridEncryptionInstance = [[PEXPbHybridEncryption alloc] init];
  }
}
+ (PEXPbHybridEncryption*) defaultInstance {
  return defaultPEXPbHybridEncryptionInstance;
}
- (PEXPbHybridEncryption*) defaultInstance {
  return defaultPEXPbHybridEncryptionInstance;
}
- (BOOL) isInitialized {
  if (!self.hasACiphertext) {
    return NO;
  }
  if (!self.extensionsAreInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasVersion) {
    [output writeInt32:1 value:self.version];
  }
  if (self.hasACiphertext) {
    [output writeData:2 value:self.aCiphertext];
  }
  if (self.hasIv) {
    [output writeData:3 value:self.iv];
  }
  if (self.hasSCiphertext) {
    [output writeData:4 value:self.sCiphertext];
  }
  [self writeExtensionsToCodedOutputStream:output
                                      from:100
                                        to:200];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasVersion) {
    size_ += computeInt32Size(1, self.version);
  }
  if (self.hasACiphertext) {
    size_ += computeDataSize(2, self.aCiphertext);
  }
  if (self.hasIv) {
    size_ += computeDataSize(3, self.iv);
  }
  if (self.hasSCiphertext) {
    size_ += computeDataSize(4, self.sCiphertext);
  }
  size_ += [self extensionsSerializedSize];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbHybridEncryption*) parseFromData:(NSData*) data {
  return (PEXPbHybridEncryption*)[[[PEXPbHybridEncryption builder] mergeFromData:data] build];
}
+ (PEXPbHybridEncryption*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbHybridEncryption*)[[[PEXPbHybridEncryption builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbHybridEncryption*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbHybridEncryption*)[[[PEXPbHybridEncryption builder] mergeFromInputStream:input] build];
}
+ (PEXPbHybridEncryption*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbHybridEncryption*)[[[PEXPbHybridEncryption builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbHybridEncryption*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbHybridEncryption*)[[[PEXPbHybridEncryption builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbHybridEncryption*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbHybridEncryption*)[[[PEXPbHybridEncryption builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbHybridEncryptionBuilder*) builder {
  return [[PEXPbHybridEncryptionBuilder alloc] init];
}
+ (PEXPbHybridEncryptionBuilder*) builderWithPrototype:(PEXPbHybridEncryption*) prototype {
  return [[PEXPbHybridEncryption builder] mergeFrom:prototype];
}
- (PEXPbHybridEncryptionBuilder*) builder {
  return [PEXPbHybridEncryption builder];
}
- (PEXPbHybridEncryptionBuilder*) toBuilder {
  return [PEXPbHybridEncryption builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  if (self.hasACiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"aCiphertext", self.aCiphertext];
  }
  if (self.hasIv) {
    [output appendFormat:@"%@%@: %@\n", indent, @"iv", self.iv];
  }
  if (self.hasSCiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sCiphertext", self.sCiphertext];
  }
  [self writeExtensionDescriptionToMutableString:(NSMutableString*)output
                                            from:100
                                              to:200
                                      withIndent:indent];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbHybridEncryption class]]) {
    return NO;
  }
  PEXPbHybridEncryption *otherMessage = other;
  return
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      self.hasACiphertext == otherMessage.hasACiphertext &&
      (!self.hasACiphertext || [self.aCiphertext isEqual:otherMessage.aCiphertext]) &&
      self.hasIv == otherMessage.hasIv &&
      (!self.hasIv || [self.iv isEqual:otherMessage.iv]) &&
      self.hasSCiphertext == otherMessage.hasSCiphertext &&
      (!self.hasSCiphertext || [self.sCiphertext isEqual:otherMessage.sCiphertext]) &&
      [self isEqualExtensionsInOther:otherMessage from:100 to:200] &&

      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  if (self.hasACiphertext) {
    hashCode = hashCode * 31 + [self.aCiphertext hash];
  }
  if (self.hasIv) {
    hashCode = hashCode * 31 + [self.iv hash];
  }
  if (self.hasSCiphertext) {
    hashCode = hashCode * 31 + [self.sCiphertext hash];
  }
  hashCode = hashCode * 31 + [self hashExtensionsFrom:100 to:200];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbHybridEncryptionBuilder()
@property (strong) PEXPbHybridEncryption* result;
@end

@implementation PEXPbHybridEncryptionBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbHybridEncryption alloc] init];
  }
  return self;
}
- (PBExtendableMessage*) internalGetResult {
  return result;
}
- (PEXPbHybridEncryptionBuilder*) clear {
  self.result = [[PEXPbHybridEncryption alloc] init];
  return self;
}
- (PEXPbHybridEncryptionBuilder*) clone {
  return [PEXPbHybridEncryption builderWithPrototype:result];
}
- (PEXPbHybridEncryption*) defaultInstance {
  return [PEXPbHybridEncryption defaultInstance];
}
- (PEXPbHybridEncryption*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbHybridEncryption*) buildPartial {
  PEXPbHybridEncryption* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbHybridEncryptionBuilder*) mergeFrom:(PEXPbHybridEncryption*) other {
  if (other == [PEXPbHybridEncryption defaultInstance]) {
    return self;
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasACiphertext) {
    [self setACiphertext:other.aCiphertext];
  }
  if (other.hasIv) {
    [self setIv:other.iv];
  }
  if (other.hasSCiphertext) {
    [self setSCiphertext:other.sCiphertext];
  }
  [self mergeExtensionFields:other];
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbHybridEncryptionBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbHybridEncryptionBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setVersion:[input readInt32]];
        break;
      }
      case 18: {
        [self setACiphertext:[input readData]];
        break;
      }
      case 26: {
        [self setIv:[input readData]];
        break;
      }
      case 34: {
        [self setSCiphertext:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (SInt32) version {
  return result.version;
}
- (PEXPbHybridEncryptionBuilder*) setVersion:(SInt32) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (PEXPbHybridEncryptionBuilder*) clearVersion {
  result.hasVersion = NO;
  result.version = 1;
  return self;
}
- (BOOL) hasACiphertext {
  return result.hasACiphertext;
}
- (NSData*) aCiphertext {
  return result.aCiphertext;
}
- (PEXPbHybridEncryptionBuilder*) setACiphertext:(NSData*) value {
  result.hasACiphertext = YES;
  result.aCiphertext = value;
  return self;
}
- (PEXPbHybridEncryptionBuilder*) clearACiphertext {
  result.hasACiphertext = NO;
  result.aCiphertext = [NSData data];
  return self;
}
- (BOOL) hasIv {
  return result.hasIv;
}
- (NSData*) iv {
  return result.iv;
}
- (PEXPbHybridEncryptionBuilder*) setIv:(NSData*) value {
  result.hasIv = YES;
  result.iv = value;
  return self;
}
- (PEXPbHybridEncryptionBuilder*) clearIv {
  result.hasIv = NO;
  result.iv = [NSData data];
  return self;
}
- (BOOL) hasSCiphertext {
  return result.hasSCiphertext;
}
- (NSData*) sCiphertext {
  return result.sCiphertext;
}
- (PEXPbHybridEncryptionBuilder*) setSCiphertext:(NSData*) value {
  result.hasSCiphertext = YES;
  result.sCiphertext = value;
  return self;
}
- (PEXPbHybridEncryptionBuilder*) clearSCiphertext {
  result.hasSCiphertext = NO;
  result.sCiphertext = [NSData data];
  return self;
}
@end

@interface PEXPbGetDHKeyResponseBodySCip ()
@property UInt32 dhGroupId;
@property (strong) NSData* gx;
@property (strong) NSString* nonce1;
@property (strong) NSData* sig1;
@end

@implementation PEXPbGetDHKeyResponseBodySCip

- (BOOL) hasDhGroupId {
  return !!hasDhGroupId_;
}
- (void) setHasDhGroupId:(BOOL) value_ {
  hasDhGroupId_ = !!value_;
}
@synthesize dhGroupId;
- (BOOL) hasGx {
  return !!hasGx_;
}
- (void) setHasGx:(BOOL) value_ {
  hasGx_ = !!value_;
}
@synthesize gx;
- (BOOL) hasNonce1 {
  return !!hasNonce1_;
}
- (void) setHasNonce1:(BOOL) value_ {
  hasNonce1_ = !!value_;
}
@synthesize nonce1;
- (BOOL) hasSig1 {
  return !!hasSig1_;
}
- (void) setHasSig1:(BOOL) value_ {
  hasSig1_ = !!value_;
}
@synthesize sig1;
- (id) init {
  if ((self = [super init])) {
    self.dhGroupId = 0;
    self.gx = [NSData data];
    self.nonce1 = @"";
    self.sig1 = [NSData data];
  }
  return self;
}
static PEXPbGetDHKeyResponseBodySCip* defaultPEXPbGetDHKeyResponseBodySCipInstance = nil;
+ (void) initialize {
  if (self == [PEXPbGetDHKeyResponseBodySCip class]) {
    defaultPEXPbGetDHKeyResponseBodySCipInstance = [[PEXPbGetDHKeyResponseBodySCip alloc] init];
  }
}
+ (PEXPbGetDHKeyResponseBodySCip*) defaultInstance {
  return defaultPEXPbGetDHKeyResponseBodySCipInstance;
}
- (PEXPbGetDHKeyResponseBodySCip*) defaultInstance {
  return defaultPEXPbGetDHKeyResponseBodySCipInstance;
}
- (BOOL) isInitialized {
  if (!self.hasDhGroupId) {
    return NO;
  }
  if (!self.hasGx) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasDhGroupId) {
    [output writeUInt32:1 value:self.dhGroupId];
  }
  if (self.hasGx) {
    [output writeData:2 value:self.gx];
  }
  if (self.hasNonce1) {
    [output writeString:3 value:self.nonce1];
  }
  if (self.hasSig1) {
    [output writeData:4 value:self.sig1];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasDhGroupId) {
    size_ += computeUInt32Size(1, self.dhGroupId);
  }
  if (self.hasGx) {
    size_ += computeDataSize(2, self.gx);
  }
  if (self.hasNonce1) {
    size_ += computeStringSize(3, self.nonce1);
  }
  if (self.hasSig1) {
    size_ += computeDataSize(4, self.sig1);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbGetDHKeyResponseBodySCip*) parseFromData:(NSData*) data {
  return (PEXPbGetDHKeyResponseBodySCip*)[[[PEXPbGetDHKeyResponseBodySCip builder] mergeFromData:data] build];
}
+ (PEXPbGetDHKeyResponseBodySCip*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbGetDHKeyResponseBodySCip*)[[[PEXPbGetDHKeyResponseBodySCip builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbGetDHKeyResponseBodySCip*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbGetDHKeyResponseBodySCip*)[[[PEXPbGetDHKeyResponseBodySCip builder] mergeFromInputStream:input] build];
}
+ (PEXPbGetDHKeyResponseBodySCip*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbGetDHKeyResponseBodySCip*)[[[PEXPbGetDHKeyResponseBodySCip builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbGetDHKeyResponseBodySCip*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbGetDHKeyResponseBodySCip*)[[[PEXPbGetDHKeyResponseBodySCip builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbGetDHKeyResponseBodySCip*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbGetDHKeyResponseBodySCip*)[[[PEXPbGetDHKeyResponseBodySCip builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbGetDHKeyResponseBodySCipBuilder*) builder {
  return [[PEXPbGetDHKeyResponseBodySCipBuilder alloc] init];
}
+ (PEXPbGetDHKeyResponseBodySCipBuilder*) builderWithPrototype:(PEXPbGetDHKeyResponseBodySCip*) prototype {
  return [[PEXPbGetDHKeyResponseBodySCip builder] mergeFrom:prototype];
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) builder {
  return [PEXPbGetDHKeyResponseBodySCip builder];
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) toBuilder {
  return [PEXPbGetDHKeyResponseBodySCip builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasDhGroupId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"dhGroupId", [NSNumber numberWithInteger:self.dhGroupId]];
  }
  if (self.hasGx) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gx", self.gx];
  }
  if (self.hasNonce1) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonce1", self.nonce1];
  }
  if (self.hasSig1) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sig1", self.sig1];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbGetDHKeyResponseBodySCip class]]) {
    return NO;
  }
  PEXPbGetDHKeyResponseBodySCip *otherMessage = other;
  return
      self.hasDhGroupId == otherMessage.hasDhGroupId &&
      (!self.hasDhGroupId || self.dhGroupId == otherMessage.dhGroupId) &&
      self.hasGx == otherMessage.hasGx &&
      (!self.hasGx || [self.gx isEqual:otherMessage.gx]) &&
      self.hasNonce1 == otherMessage.hasNonce1 &&
      (!self.hasNonce1 || [self.nonce1 isEqual:otherMessage.nonce1]) &&
      self.hasSig1 == otherMessage.hasSig1 &&
      (!self.hasSig1 || [self.sig1 isEqual:otherMessage.sig1]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasDhGroupId) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.dhGroupId] hash];
  }
  if (self.hasGx) {
    hashCode = hashCode * 31 + [self.gx hash];
  }
  if (self.hasNonce1) {
    hashCode = hashCode * 31 + [self.nonce1 hash];
  }
  if (self.hasSig1) {
    hashCode = hashCode * 31 + [self.sig1 hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbGetDHKeyResponseBodySCipBuilder()
@property (strong) PEXPbGetDHKeyResponseBodySCip* result;
@end

@implementation PEXPbGetDHKeyResponseBodySCipBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbGetDHKeyResponseBodySCip alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) clear {
  self.result = [[PEXPbGetDHKeyResponseBodySCip alloc] init];
  return self;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) clone {
  return [PEXPbGetDHKeyResponseBodySCip builderWithPrototype:result];
}
- (PEXPbGetDHKeyResponseBodySCip*) defaultInstance {
  return [PEXPbGetDHKeyResponseBodySCip defaultInstance];
}
- (PEXPbGetDHKeyResponseBodySCip*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbGetDHKeyResponseBodySCip*) buildPartial {
  PEXPbGetDHKeyResponseBodySCip* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) mergeFrom:(PEXPbGetDHKeyResponseBodySCip*) other {
  if (other == [PEXPbGetDHKeyResponseBodySCip defaultInstance]) {
    return self;
  }
  if (other.hasDhGroupId) {
    [self setDhGroupId:other.dhGroupId];
  }
  if (other.hasGx) {
    [self setGx:other.gx];
  }
  if (other.hasNonce1) {
    [self setNonce1:other.nonce1];
  }
  if (other.hasSig1) {
    [self setSig1:other.sig1];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setDhGroupId:[input readUInt32]];
        break;
      }
      case 18: {
        [self setGx:[input readData]];
        break;
      }
      case 26: {
        [self setNonce1:[input readString]];
        break;
      }
      case 34: {
        [self setSig1:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasDhGroupId {
  return result.hasDhGroupId;
}
- (UInt32) dhGroupId {
  return result.dhGroupId;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) setDhGroupId:(UInt32) value {
  result.hasDhGroupId = YES;
  result.dhGroupId = value;
  return self;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) clearDhGroupId {
  result.hasDhGroupId = NO;
  result.dhGroupId = 0;
  return self;
}
- (BOOL) hasGx {
  return result.hasGx;
}
- (NSData*) gx {
  return result.gx;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) setGx:(NSData*) value {
  result.hasGx = YES;
  result.gx = value;
  return self;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) clearGx {
  result.hasGx = NO;
  result.gx = [NSData data];
  return self;
}
- (BOOL) hasNonce1 {
  return result.hasNonce1;
}
- (NSString*) nonce1 {
  return result.nonce1;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) setNonce1:(NSString*) value {
  result.hasNonce1 = YES;
  result.nonce1 = value;
  return self;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) clearNonce1 {
  result.hasNonce1 = NO;
  result.nonce1 = @"";
  return self;
}
- (BOOL) hasSig1 {
  return result.hasSig1;
}
- (NSData*) sig1 {
  return result.sig1;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) setSig1:(NSData*) value {
  result.hasSig1 = YES;
  result.sig1 = value;
  return self;
}
- (PEXPbGetDHKeyResponseBodySCipBuilder*) clearSig1 {
  result.hasSig1 = NO;
  result.sig1 = [NSData data];
  return self;
}
@end

@interface PEXPbDhkeySig ()
@property UInt32 version;
@property (strong) NSString* b;
@property (strong) NSString* bCertHash;
@property (strong) NSString* a;
@property (strong) NSString* aCertHash;
@property UInt32 dhGroupId;
@property (strong) NSData* gx;
@property (strong) NSString* nonce1;
@property (strong) NSString* nonce2;
@end

@implementation PEXPbDhkeySig

- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
- (BOOL) hasB {
  return !!hasB_;
}
- (void) setHasB:(BOOL) value_ {
  hasB_ = !!value_;
}
@synthesize b;
- (BOOL) hasBCertHash {
  return !!hasBCertHash_;
}
- (void) setHasBCertHash:(BOOL) value_ {
  hasBCertHash_ = !!value_;
}
@synthesize bCertHash;
- (BOOL) hasA {
  return !!hasA_;
}
- (void) setHasA:(BOOL) value_ {
  hasA_ = !!value_;
}
@synthesize a;
- (BOOL) hasACertHash {
  return !!hasACertHash_;
}
- (void) setHasACertHash:(BOOL) value_ {
  hasACertHash_ = !!value_;
}
@synthesize aCertHash;
- (BOOL) hasDhGroupId {
  return !!hasDhGroupId_;
}
- (void) setHasDhGroupId:(BOOL) value_ {
  hasDhGroupId_ = !!value_;
}
@synthesize dhGroupId;
- (BOOL) hasGx {
  return !!hasGx_;
}
- (void) setHasGx:(BOOL) value_ {
  hasGx_ = !!value_;
}
@synthesize gx;
- (BOOL) hasNonce1 {
  return !!hasNonce1_;
}
- (void) setHasNonce1:(BOOL) value_ {
  hasNonce1_ = !!value_;
}
@synthesize nonce1;
- (BOOL) hasNonce2 {
  return !!hasNonce2_;
}
- (void) setHasNonce2:(BOOL) value_ {
  hasNonce2_ = !!value_;
}
@synthesize nonce2;
- (id) init {
  if ((self = [super init])) {
    self.version = 1;
    self.b = @"";
    self.bCertHash = @"";
    self.a = @"";
    self.aCertHash = @"";
    self.dhGroupId = 0;
    self.gx = [NSData data];
    self.nonce1 = @"";
    self.nonce2 = @"";
  }
  return self;
}
static PEXPbDhkeySig* defaultPEXPbDhkeySigInstance = nil;
+ (void) initialize {
  if (self == [PEXPbDhkeySig class]) {
    defaultPEXPbDhkeySigInstance = [[PEXPbDhkeySig alloc] init];
  }
}
+ (PEXPbDhkeySig*) defaultInstance {
  return defaultPEXPbDhkeySigInstance;
}
- (PEXPbDhkeySig*) defaultInstance {
  return defaultPEXPbDhkeySigInstance;
}
- (BOOL) isInitialized {
  if (!self.hasVersion) {
    return NO;
  }
  if (!self.hasB) {
    return NO;
  }
  if (!self.hasBCertHash) {
    return NO;
  }
  if (!self.hasA) {
    return NO;
  }
  if (!self.hasACertHash) {
    return NO;
  }
  if (!self.hasDhGroupId) {
    return NO;
  }
  if (!self.hasGx) {
    return NO;
  }
  if (!self.hasNonce1) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasVersion) {
    [output writeUInt32:1 value:self.version];
  }
  if (self.hasB) {
    [output writeString:2 value:self.b];
  }
  if (self.hasBCertHash) {
    [output writeString:3 value:self.bCertHash];
  }
  if (self.hasA) {
    [output writeString:4 value:self.a];
  }
  if (self.hasACertHash) {
    [output writeString:5 value:self.aCertHash];
  }
  if (self.hasDhGroupId) {
    [output writeUInt32:6 value:self.dhGroupId];
  }
  if (self.hasGx) {
    [output writeData:7 value:self.gx];
  }
  if (self.hasNonce1) {
    [output writeString:8 value:self.nonce1];
  }
  if (self.hasNonce2) {
    [output writeString:9 value:self.nonce2];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasVersion) {
    size_ += computeUInt32Size(1, self.version);
  }
  if (self.hasB) {
    size_ += computeStringSize(2, self.b);
  }
  if (self.hasBCertHash) {
    size_ += computeStringSize(3, self.bCertHash);
  }
  if (self.hasA) {
    size_ += computeStringSize(4, self.a);
  }
  if (self.hasACertHash) {
    size_ += computeStringSize(5, self.aCertHash);
  }
  if (self.hasDhGroupId) {
    size_ += computeUInt32Size(6, self.dhGroupId);
  }
  if (self.hasGx) {
    size_ += computeDataSize(7, self.gx);
  }
  if (self.hasNonce1) {
    size_ += computeStringSize(8, self.nonce1);
  }
  if (self.hasNonce2) {
    size_ += computeStringSize(9, self.nonce2);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbDhkeySig*) parseFromData:(NSData*) data {
  return (PEXPbDhkeySig*)[[[PEXPbDhkeySig builder] mergeFromData:data] build];
}
+ (PEXPbDhkeySig*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbDhkeySig*)[[[PEXPbDhkeySig builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbDhkeySig*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbDhkeySig*)[[[PEXPbDhkeySig builder] mergeFromInputStream:input] build];
}
+ (PEXPbDhkeySig*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbDhkeySig*)[[[PEXPbDhkeySig builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbDhkeySig*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbDhkeySig*)[[[PEXPbDhkeySig builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbDhkeySig*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbDhkeySig*)[[[PEXPbDhkeySig builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbDhkeySigBuilder*) builder {
  return [[PEXPbDhkeySigBuilder alloc] init];
}
+ (PEXPbDhkeySigBuilder*) builderWithPrototype:(PEXPbDhkeySig*) prototype {
  return [[PEXPbDhkeySig builder] mergeFrom:prototype];
}
- (PEXPbDhkeySigBuilder*) builder {
  return [PEXPbDhkeySig builder];
}
- (PEXPbDhkeySigBuilder*) toBuilder {
  return [PEXPbDhkeySig builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  if (self.hasB) {
    [output appendFormat:@"%@%@: %@\n", indent, @"b", self.b];
  }
  if (self.hasBCertHash) {
    [output appendFormat:@"%@%@: %@\n", indent, @"bCertHash", self.bCertHash];
  }
  if (self.hasA) {
    [output appendFormat:@"%@%@: %@\n", indent, @"a", self.a];
  }
  if (self.hasACertHash) {
    [output appendFormat:@"%@%@: %@\n", indent, @"aCertHash", self.aCertHash];
  }
  if (self.hasDhGroupId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"dhGroupId", [NSNumber numberWithInteger:self.dhGroupId]];
  }
  if (self.hasGx) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gx", self.gx];
  }
  if (self.hasNonce1) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonce1", self.nonce1];
  }
  if (self.hasNonce2) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonce2", self.nonce2];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbDhkeySig class]]) {
    return NO;
  }
  PEXPbDhkeySig *otherMessage = other;
  return
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      self.hasB == otherMessage.hasB &&
      (!self.hasB || [self.b isEqual:otherMessage.b]) &&
      self.hasBCertHash == otherMessage.hasBCertHash &&
      (!self.hasBCertHash || [self.bCertHash isEqual:otherMessage.bCertHash]) &&
      self.hasA == otherMessage.hasA &&
      (!self.hasA || [self.a isEqual:otherMessage.a]) &&
      self.hasACertHash == otherMessage.hasACertHash &&
      (!self.hasACertHash || [self.aCertHash isEqual:otherMessage.aCertHash]) &&
      self.hasDhGroupId == otherMessage.hasDhGroupId &&
      (!self.hasDhGroupId || self.dhGroupId == otherMessage.dhGroupId) &&
      self.hasGx == otherMessage.hasGx &&
      (!self.hasGx || [self.gx isEqual:otherMessage.gx]) &&
      self.hasNonce1 == otherMessage.hasNonce1 &&
      (!self.hasNonce1 || [self.nonce1 isEqual:otherMessage.nonce1]) &&
      self.hasNonce2 == otherMessage.hasNonce2 &&
      (!self.hasNonce2 || [self.nonce2 isEqual:otherMessage.nonce2]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  if (self.hasB) {
    hashCode = hashCode * 31 + [self.b hash];
  }
  if (self.hasBCertHash) {
    hashCode = hashCode * 31 + [self.bCertHash hash];
  }
  if (self.hasA) {
    hashCode = hashCode * 31 + [self.a hash];
  }
  if (self.hasACertHash) {
    hashCode = hashCode * 31 + [self.aCertHash hash];
  }
  if (self.hasDhGroupId) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.dhGroupId] hash];
  }
  if (self.hasGx) {
    hashCode = hashCode * 31 + [self.gx hash];
  }
  if (self.hasNonce1) {
    hashCode = hashCode * 31 + [self.nonce1 hash];
  }
  if (self.hasNonce2) {
    hashCode = hashCode * 31 + [self.nonce2 hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbDhkeySigBuilder()
@property (strong) PEXPbDhkeySig* result;
@end

@implementation PEXPbDhkeySigBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbDhkeySig alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbDhkeySigBuilder*) clear {
  self.result = [[PEXPbDhkeySig alloc] init];
  return self;
}
- (PEXPbDhkeySigBuilder*) clone {
  return [PEXPbDhkeySig builderWithPrototype:result];
}
- (PEXPbDhkeySig*) defaultInstance {
  return [PEXPbDhkeySig defaultInstance];
}
- (PEXPbDhkeySig*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbDhkeySig*) buildPartial {
  PEXPbDhkeySig* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbDhkeySigBuilder*) mergeFrom:(PEXPbDhkeySig*) other {
  if (other == [PEXPbDhkeySig defaultInstance]) {
    return self;
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasB) {
    [self setB:other.b];
  }
  if (other.hasBCertHash) {
    [self setBCertHash:other.bCertHash];
  }
  if (other.hasA) {
    [self setA:other.a];
  }
  if (other.hasACertHash) {
    [self setACertHash:other.aCertHash];
  }
  if (other.hasDhGroupId) {
    [self setDhGroupId:other.dhGroupId];
  }
  if (other.hasGx) {
    [self setGx:other.gx];
  }
  if (other.hasNonce1) {
    [self setNonce1:other.nonce1];
  }
  if (other.hasNonce2) {
    [self setNonce2:other.nonce2];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbDhkeySigBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbDhkeySigBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setVersion:[input readUInt32]];
        break;
      }
      case 18: {
        [self setB:[input readString]];
        break;
      }
      case 26: {
        [self setBCertHash:[input readString]];
        break;
      }
      case 34: {
        [self setA:[input readString]];
        break;
      }
      case 42: {
        [self setACertHash:[input readString]];
        break;
      }
      case 48: {
        [self setDhGroupId:[input readUInt32]];
        break;
      }
      case 58: {
        [self setGx:[input readData]];
        break;
      }
      case 66: {
        [self setNonce1:[input readString]];
        break;
      }
      case 74: {
        [self setNonce2:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (UInt32) version {
  return result.version;
}
- (PEXPbDhkeySigBuilder*) setVersion:(UInt32) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearVersion {
  result.hasVersion = NO;
  result.version = 1;
  return self;
}
- (BOOL) hasB {
  return result.hasB;
}
- (NSString*) b {
  return result.b;
}
- (PEXPbDhkeySigBuilder*) setB:(NSString*) value {
  result.hasB = YES;
  result.b = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearB {
  result.hasB = NO;
  result.b = @"";
  return self;
}
- (BOOL) hasBCertHash {
  return result.hasBCertHash;
}
- (NSString*) bCertHash {
  return result.bCertHash;
}
- (PEXPbDhkeySigBuilder*) setBCertHash:(NSString*) value {
  result.hasBCertHash = YES;
  result.bCertHash = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearBCertHash {
  result.hasBCertHash = NO;
  result.bCertHash = @"";
  return self;
}
- (BOOL) hasA {
  return result.hasA;
}
- (NSString*) a {
  return result.a;
}
- (PEXPbDhkeySigBuilder*) setA:(NSString*) value {
  result.hasA = YES;
  result.a = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearA {
  result.hasA = NO;
  result.a = @"";
  return self;
}
- (BOOL) hasACertHash {
  return result.hasACertHash;
}
- (NSString*) aCertHash {
  return result.aCertHash;
}
- (PEXPbDhkeySigBuilder*) setACertHash:(NSString*) value {
  result.hasACertHash = YES;
  result.aCertHash = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearACertHash {
  result.hasACertHash = NO;
  result.aCertHash = @"";
  return self;
}
- (BOOL) hasDhGroupId {
  return result.hasDhGroupId;
}
- (UInt32) dhGroupId {
  return result.dhGroupId;
}
- (PEXPbDhkeySigBuilder*) setDhGroupId:(UInt32) value {
  result.hasDhGroupId = YES;
  result.dhGroupId = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearDhGroupId {
  result.hasDhGroupId = NO;
  result.dhGroupId = 0;
  return self;
}
- (BOOL) hasGx {
  return result.hasGx;
}
- (NSData*) gx {
  return result.gx;
}
- (PEXPbDhkeySigBuilder*) setGx:(NSData*) value {
  result.hasGx = YES;
  result.gx = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearGx {
  result.hasGx = NO;
  result.gx = [NSData data];
  return self;
}
- (BOOL) hasNonce1 {
  return result.hasNonce1;
}
- (NSString*) nonce1 {
  return result.nonce1;
}
- (PEXPbDhkeySigBuilder*) setNonce1:(NSString*) value {
  result.hasNonce1 = YES;
  result.nonce1 = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearNonce1 {
  result.hasNonce1 = NO;
  result.nonce1 = @"";
  return self;
}
- (BOOL) hasNonce2 {
  return result.hasNonce2;
}
- (NSString*) nonce2 {
  return result.nonce2;
}
- (PEXPbDhkeySigBuilder*) setNonce2:(NSString*) value {
  result.hasNonce2 = YES;
  result.nonce2 = value;
  return self;
}
- (PEXPbDhkeySigBuilder*) clearNonce2 {
  result.hasNonce2 = NO;
  result.nonce2 = @"";
  return self;
}
@end

@interface PEXPbAuthEnc ()
@property (strong) NSData* iv;
@property (strong) NSData* sCiphertext;
@property (strong) NSData* mac;
@end

@implementation PEXPbAuthEnc

- (BOOL) hasIv {
  return !!hasIv_;
}
- (void) setHasIv:(BOOL) value_ {
  hasIv_ = !!value_;
}
@synthesize iv;
- (BOOL) hasSCiphertext {
  return !!hasSCiphertext_;
}
- (void) setHasSCiphertext:(BOOL) value_ {
  hasSCiphertext_ = !!value_;
}
@synthesize sCiphertext;
- (BOOL) hasMac {
  return !!hasMac_;
}
- (void) setHasMac:(BOOL) value_ {
  hasMac_ = !!value_;
}
@synthesize mac;
- (id) init {
  if ((self = [super init])) {
    self.iv = [NSData data];
    self.sCiphertext = [NSData data];
    self.mac = [NSData data];
  }
  return self;
}
static PEXPbAuthEnc* defaultPEXPbAuthEncInstance = nil;
+ (void) initialize {
  if (self == [PEXPbAuthEnc class]) {
    defaultPEXPbAuthEncInstance = [[PEXPbAuthEnc alloc] init];
  }
}
+ (PEXPbAuthEnc*) defaultInstance {
  return defaultPEXPbAuthEncInstance;
}
- (PEXPbAuthEnc*) defaultInstance {
  return defaultPEXPbAuthEncInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasIv) {
    [output writeData:1 value:self.iv];
  }
  if (self.hasSCiphertext) {
    [output writeData:2 value:self.sCiphertext];
  }
  if (self.hasMac) {
    [output writeData:3 value:self.mac];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasIv) {
    size_ += computeDataSize(1, self.iv);
  }
  if (self.hasSCiphertext) {
    size_ += computeDataSize(2, self.sCiphertext);
  }
  if (self.hasMac) {
    size_ += computeDataSize(3, self.mac);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbAuthEnc*) parseFromData:(NSData*) data {
  return (PEXPbAuthEnc*)[[[PEXPbAuthEnc builder] mergeFromData:data] build];
}
+ (PEXPbAuthEnc*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbAuthEnc*)[[[PEXPbAuthEnc builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbAuthEnc*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbAuthEnc*)[[[PEXPbAuthEnc builder] mergeFromInputStream:input] build];
}
+ (PEXPbAuthEnc*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbAuthEnc*)[[[PEXPbAuthEnc builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbAuthEnc*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbAuthEnc*)[[[PEXPbAuthEnc builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbAuthEnc*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbAuthEnc*)[[[PEXPbAuthEnc builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbAuthEncBuilder*) builder {
  return [[PEXPbAuthEncBuilder alloc] init];
}
+ (PEXPbAuthEncBuilder*) builderWithPrototype:(PEXPbAuthEnc*) prototype {
  return [[PEXPbAuthEnc builder] mergeFrom:prototype];
}
- (PEXPbAuthEncBuilder*) builder {
  return [PEXPbAuthEnc builder];
}
- (PEXPbAuthEncBuilder*) toBuilder {
  return [PEXPbAuthEnc builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasIv) {
    [output appendFormat:@"%@%@: %@\n", indent, @"iv", self.iv];
  }
  if (self.hasSCiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sCiphertext", self.sCiphertext];
  }
  if (self.hasMac) {
    [output appendFormat:@"%@%@: %@\n", indent, @"mac", self.mac];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbAuthEnc class]]) {
    return NO;
  }
  PEXPbAuthEnc *otherMessage = other;
  return
      self.hasIv == otherMessage.hasIv &&
      (!self.hasIv || [self.iv isEqual:otherMessage.iv]) &&
      self.hasSCiphertext == otherMessage.hasSCiphertext &&
      (!self.hasSCiphertext || [self.sCiphertext isEqual:otherMessage.sCiphertext]) &&
      self.hasMac == otherMessage.hasMac &&
      (!self.hasMac || [self.mac isEqual:otherMessage.mac]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasIv) {
    hashCode = hashCode * 31 + [self.iv hash];
  }
  if (self.hasSCiphertext) {
    hashCode = hashCode * 31 + [self.sCiphertext hash];
  }
  if (self.hasMac) {
    hashCode = hashCode * 31 + [self.mac hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbAuthEncBuilder()
@property (strong) PEXPbAuthEnc* result;
@end

@implementation PEXPbAuthEncBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbAuthEnc alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbAuthEncBuilder*) clear {
  self.result = [[PEXPbAuthEnc alloc] init];
  return self;
}
- (PEXPbAuthEncBuilder*) clone {
  return [PEXPbAuthEnc builderWithPrototype:result];
}
- (PEXPbAuthEnc*) defaultInstance {
  return [PEXPbAuthEnc defaultInstance];
}
- (PEXPbAuthEnc*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbAuthEnc*) buildPartial {
  PEXPbAuthEnc* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbAuthEncBuilder*) mergeFrom:(PEXPbAuthEnc*) other {
  if (other == [PEXPbAuthEnc defaultInstance]) {
    return self;
  }
  if (other.hasIv) {
    [self setIv:other.iv];
  }
  if (other.hasSCiphertext) {
    [self setSCiphertext:other.sCiphertext];
  }
  if (other.hasMac) {
    [self setMac:other.mac];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbAuthEncBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbAuthEncBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setIv:[input readData]];
        break;
      }
      case 18: {
        [self setSCiphertext:[input readData]];
        break;
      }
      case 26: {
        [self setMac:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasIv {
  return result.hasIv;
}
- (NSData*) iv {
  return result.iv;
}
- (PEXPbAuthEncBuilder*) setIv:(NSData*) value {
  result.hasIv = YES;
  result.iv = value;
  return self;
}
- (PEXPbAuthEncBuilder*) clearIv {
  result.hasIv = NO;
  result.iv = [NSData data];
  return self;
}
- (BOOL) hasSCiphertext {
  return result.hasSCiphertext;
}
- (NSData*) sCiphertext {
  return result.sCiphertext;
}
- (PEXPbAuthEncBuilder*) setSCiphertext:(NSData*) value {
  result.hasSCiphertext = YES;
  result.sCiphertext = value;
  return self;
}
- (PEXPbAuthEncBuilder*) clearSCiphertext {
  result.hasSCiphertext = NO;
  result.sCiphertext = [NSData data];
  return self;
}
- (BOOL) hasMac {
  return result.hasMac;
}
- (NSData*) mac {
  return result.mac;
}
- (PEXPbAuthEncBuilder*) setMac:(NSData*) value {
  result.hasMac = YES;
  result.mac = value;
  return self;
}
- (PEXPbAuthEncBuilder*) clearMac {
  result.hasMac = NO;
  result.mac = [NSData data];
  return self;
}
@end

@interface PEXPbUploadFileKey ()
@property (strong) NSData* saltb;
@property (strong) NSData* gy;
@property (strong) NSData* sCiphertext;
@property (strong) NSData* mac;
@end

@implementation PEXPbUploadFileKey

- (BOOL) hasSaltb {
  return !!hasSaltb_;
}
- (void) setHasSaltb:(BOOL) value_ {
  hasSaltb_ = !!value_;
}
@synthesize saltb;
- (BOOL) hasGy {
  return !!hasGy_;
}
- (void) setHasGy:(BOOL) value_ {
  hasGy_ = !!value_;
}
@synthesize gy;
- (BOOL) hasSCiphertext {
  return !!hasSCiphertext_;
}
- (void) setHasSCiphertext:(BOOL) value_ {
  hasSCiphertext_ = !!value_;
}
@synthesize sCiphertext;
- (BOOL) hasMac {
  return !!hasMac_;
}
- (void) setHasMac:(BOOL) value_ {
  hasMac_ = !!value_;
}
@synthesize mac;
- (id) init {
  if ((self = [super init])) {
    self.saltb = [NSData data];
    self.gy = [NSData data];
    self.sCiphertext = [NSData data];
    self.mac = [NSData data];
  }
  return self;
}
static PEXPbUploadFileKey* defaultPEXPbUploadFileKeyInstance = nil;
+ (void) initialize {
  if (self == [PEXPbUploadFileKey class]) {
    defaultPEXPbUploadFileKeyInstance = [[PEXPbUploadFileKey alloc] init];
  }
}
+ (PEXPbUploadFileKey*) defaultInstance {
  return defaultPEXPbUploadFileKeyInstance;
}
- (PEXPbUploadFileKey*) defaultInstance {
  return defaultPEXPbUploadFileKeyInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSaltb) {
    [output writeData:1 value:self.saltb];
  }
  if (self.hasGy) {
    [output writeData:2 value:self.gy];
  }
  if (self.hasSCiphertext) {
    [output writeData:3 value:self.sCiphertext];
  }
  if (self.hasMac) {
    [output writeData:4 value:self.mac];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasSaltb) {
    size_ += computeDataSize(1, self.saltb);
  }
  if (self.hasGy) {
    size_ += computeDataSize(2, self.gy);
  }
  if (self.hasSCiphertext) {
    size_ += computeDataSize(3, self.sCiphertext);
  }
  if (self.hasMac) {
    size_ += computeDataSize(4, self.mac);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbUploadFileKey*) parseFromData:(NSData*) data {
  return (PEXPbUploadFileKey*)[[[PEXPbUploadFileKey builder] mergeFromData:data] build];
}
+ (PEXPbUploadFileKey*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileKey*)[[[PEXPbUploadFileKey builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileKey*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbUploadFileKey*)[[[PEXPbUploadFileKey builder] mergeFromInputStream:input] build];
}
+ (PEXPbUploadFileKey*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileKey*)[[[PEXPbUploadFileKey builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileKey*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbUploadFileKey*)[[[PEXPbUploadFileKey builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbUploadFileKey*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileKey*)[[[PEXPbUploadFileKey builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileKeyBuilder*) builder {
  return [[PEXPbUploadFileKeyBuilder alloc] init];
}
+ (PEXPbUploadFileKeyBuilder*) builderWithPrototype:(PEXPbUploadFileKey*) prototype {
  return [[PEXPbUploadFileKey builder] mergeFrom:prototype];
}
- (PEXPbUploadFileKeyBuilder*) builder {
  return [PEXPbUploadFileKey builder];
}
- (PEXPbUploadFileKeyBuilder*) toBuilder {
  return [PEXPbUploadFileKey builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasSaltb) {
    [output appendFormat:@"%@%@: %@\n", indent, @"saltb", self.saltb];
  }
  if (self.hasGy) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gy", self.gy];
  }
  if (self.hasSCiphertext) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sCiphertext", self.sCiphertext];
  }
  if (self.hasMac) {
    [output appendFormat:@"%@%@: %@\n", indent, @"mac", self.mac];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbUploadFileKey class]]) {
    return NO;
  }
  PEXPbUploadFileKey *otherMessage = other;
  return
      self.hasSaltb == otherMessage.hasSaltb &&
      (!self.hasSaltb || [self.saltb isEqual:otherMessage.saltb]) &&
      self.hasGy == otherMessage.hasGy &&
      (!self.hasGy || [self.gy isEqual:otherMessage.gy]) &&
      self.hasSCiphertext == otherMessage.hasSCiphertext &&
      (!self.hasSCiphertext || [self.sCiphertext isEqual:otherMessage.sCiphertext]) &&
      self.hasMac == otherMessage.hasMac &&
      (!self.hasMac || [self.mac isEqual:otherMessage.mac]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasSaltb) {
    hashCode = hashCode * 31 + [self.saltb hash];
  }
  if (self.hasGy) {
    hashCode = hashCode * 31 + [self.gy hash];
  }
  if (self.hasSCiphertext) {
    hashCode = hashCode * 31 + [self.sCiphertext hash];
  }
  if (self.hasMac) {
    hashCode = hashCode * 31 + [self.mac hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbUploadFileKeyBuilder()
@property (strong) PEXPbUploadFileKey* result;
@end

@implementation PEXPbUploadFileKeyBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbUploadFileKey alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbUploadFileKeyBuilder*) clear {
  self.result = [[PEXPbUploadFileKey alloc] init];
  return self;
}
- (PEXPbUploadFileKeyBuilder*) clone {
  return [PEXPbUploadFileKey builderWithPrototype:result];
}
- (PEXPbUploadFileKey*) defaultInstance {
  return [PEXPbUploadFileKey defaultInstance];
}
- (PEXPbUploadFileKey*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbUploadFileKey*) buildPartial {
  PEXPbUploadFileKey* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbUploadFileKeyBuilder*) mergeFrom:(PEXPbUploadFileKey*) other {
  if (other == [PEXPbUploadFileKey defaultInstance]) {
    return self;
  }
  if (other.hasSaltb) {
    [self setSaltb:other.saltb];
  }
  if (other.hasGy) {
    [self setGy:other.gy];
  }
  if (other.hasSCiphertext) {
    [self setSCiphertext:other.sCiphertext];
  }
  if (other.hasMac) {
    [self setMac:other.mac];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbUploadFileKeyBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbUploadFileKeyBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setSaltb:[input readData]];
        break;
      }
      case 18: {
        [self setGy:[input readData]];
        break;
      }
      case 26: {
        [self setSCiphertext:[input readData]];
        break;
      }
      case 34: {
        [self setMac:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasSaltb {
  return result.hasSaltb;
}
- (NSData*) saltb {
  return result.saltb;
}
- (PEXPbUploadFileKeyBuilder*) setSaltb:(NSData*) value {
  result.hasSaltb = YES;
  result.saltb = value;
  return self;
}
- (PEXPbUploadFileKeyBuilder*) clearSaltb {
  result.hasSaltb = NO;
  result.saltb = [NSData data];
  return self;
}
- (BOOL) hasGy {
  return result.hasGy;
}
- (NSData*) gy {
  return result.gy;
}
- (PEXPbUploadFileKeyBuilder*) setGy:(NSData*) value {
  result.hasGy = YES;
  result.gy = value;
  return self;
}
- (PEXPbUploadFileKeyBuilder*) clearGy {
  result.hasGy = NO;
  result.gy = [NSData data];
  return self;
}
- (BOOL) hasSCiphertext {
  return result.hasSCiphertext;
}
- (NSData*) sCiphertext {
  return result.sCiphertext;
}
- (PEXPbUploadFileKeyBuilder*) setSCiphertext:(NSData*) value {
  result.hasSCiphertext = YES;
  result.sCiphertext = value;
  return self;
}
- (PEXPbUploadFileKeyBuilder*) clearSCiphertext {
  result.hasSCiphertext = NO;
  result.sCiphertext = [NSData data];
  return self;
}
- (BOOL) hasMac {
  return result.hasMac;
}
- (NSData*) mac {
  return result.mac;
}
- (PEXPbUploadFileKeyBuilder*) setMac:(NSData*) value {
  result.hasMac = YES;
  result.mac = value;
  return self;
}
- (PEXPbUploadFileKeyBuilder*) clearMac {
  result.hasMac = NO;
  result.mac = [NSData data];
  return self;
}
@end

@interface PEXPbUploadFileToMac ()
@property UInt32 version;
@property (strong) NSString* b;
@property (strong) NSString* bCertHash;
@property (strong) NSString* a;
@property (strong) NSString* aCertHash;
@property UInt32 dhGroupId;
@property (strong) NSData* gx;
@property (strong) NSData* gy;
@property (strong) NSData* gxy;
@property (strong) NSString* nonce1;
@property (strong) NSString* nonce2;
@property (strong) NSData* nonceb;
@end

@implementation PEXPbUploadFileToMac

- (BOOL) hasVersion {
  return !!hasVersion_;
}
- (void) setHasVersion:(BOOL) value_ {
  hasVersion_ = !!value_;
}
@synthesize version;
- (BOOL) hasB {
  return !!hasB_;
}
- (void) setHasB:(BOOL) value_ {
  hasB_ = !!value_;
}
@synthesize b;
- (BOOL) hasBCertHash {
  return !!hasBCertHash_;
}
- (void) setHasBCertHash:(BOOL) value_ {
  hasBCertHash_ = !!value_;
}
@synthesize bCertHash;
- (BOOL) hasA {
  return !!hasA_;
}
- (void) setHasA:(BOOL) value_ {
  hasA_ = !!value_;
}
@synthesize a;
- (BOOL) hasACertHash {
  return !!hasACertHash_;
}
- (void) setHasACertHash:(BOOL) value_ {
  hasACertHash_ = !!value_;
}
@synthesize aCertHash;
- (BOOL) hasDhGroupId {
  return !!hasDhGroupId_;
}
- (void) setHasDhGroupId:(BOOL) value_ {
  hasDhGroupId_ = !!value_;
}
@synthesize dhGroupId;
- (BOOL) hasGx {
  return !!hasGx_;
}
- (void) setHasGx:(BOOL) value_ {
  hasGx_ = !!value_;
}
@synthesize gx;
- (BOOL) hasGy {
  return !!hasGy_;
}
- (void) setHasGy:(BOOL) value_ {
  hasGy_ = !!value_;
}
@synthesize gy;
- (BOOL) hasGxy {
  return !!hasGxy_;
}
- (void) setHasGxy:(BOOL) value_ {
  hasGxy_ = !!value_;
}
@synthesize gxy;
- (BOOL) hasNonce1 {
  return !!hasNonce1_;
}
- (void) setHasNonce1:(BOOL) value_ {
  hasNonce1_ = !!value_;
}
@synthesize nonce1;
- (BOOL) hasNonce2 {
  return !!hasNonce2_;
}
- (void) setHasNonce2:(BOOL) value_ {
  hasNonce2_ = !!value_;
}
@synthesize nonce2;
- (BOOL) hasNonceb {
  return !!hasNonceb_;
}
- (void) setHasNonceb:(BOOL) value_ {
  hasNonceb_ = !!value_;
}
@synthesize nonceb;
- (id) init {
  if ((self = [super init])) {
    self.version = 1;
    self.b = @"";
    self.bCertHash = @"";
    self.a = @"";
    self.aCertHash = @"";
    self.dhGroupId = 0;
    self.gx = [NSData data];
    self.gy = [NSData data];
    self.gxy = [NSData data];
    self.nonce1 = @"";
    self.nonce2 = @"";
    self.nonceb = [NSData data];
  }
  return self;
}
static PEXPbUploadFileToMac* defaultPEXPbUploadFileToMacInstance = nil;
+ (void) initialize {
  if (self == [PEXPbUploadFileToMac class]) {
    defaultPEXPbUploadFileToMacInstance = [[PEXPbUploadFileToMac alloc] init];
  }
}
+ (PEXPbUploadFileToMac*) defaultInstance {
  return defaultPEXPbUploadFileToMacInstance;
}
- (PEXPbUploadFileToMac*) defaultInstance {
  return defaultPEXPbUploadFileToMacInstance;
}
- (BOOL) isInitialized {
  if (!self.hasVersion) {
    return NO;
  }
  if (!self.hasB) {
    return NO;
  }
  if (!self.hasBCertHash) {
    return NO;
  }
  if (!self.hasA) {
    return NO;
  }
  if (!self.hasACertHash) {
    return NO;
  }
  if (!self.hasDhGroupId) {
    return NO;
  }
  if (!self.hasGx) {
    return NO;
  }
  if (!self.hasGy) {
    return NO;
  }
  if (!self.hasGxy) {
    return NO;
  }
  if (!self.hasNonce1) {
    return NO;
  }
  if (!self.hasNonce2) {
    return NO;
  }
  if (!self.hasNonceb) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasVersion) {
    [output writeUInt32:1 value:self.version];
  }
  if (self.hasB) {
    [output writeString:2 value:self.b];
  }
  if (self.hasBCertHash) {
    [output writeString:3 value:self.bCertHash];
  }
  if (self.hasA) {
    [output writeString:4 value:self.a];
  }
  if (self.hasACertHash) {
    [output writeString:5 value:self.aCertHash];
  }
  if (self.hasDhGroupId) {
    [output writeUInt32:6 value:self.dhGroupId];
  }
  if (self.hasGx) {
    [output writeData:7 value:self.gx];
  }
  if (self.hasGy) {
    [output writeData:8 value:self.gy];
  }
  if (self.hasGxy) {
    [output writeData:9 value:self.gxy];
  }
  if (self.hasNonce1) {
    [output writeString:10 value:self.nonce1];
  }
  if (self.hasNonce2) {
    [output writeString:11 value:self.nonce2];
  }
  if (self.hasNonceb) {
    [output writeData:12 value:self.nonceb];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasVersion) {
    size_ += computeUInt32Size(1, self.version);
  }
  if (self.hasB) {
    size_ += computeStringSize(2, self.b);
  }
  if (self.hasBCertHash) {
    size_ += computeStringSize(3, self.bCertHash);
  }
  if (self.hasA) {
    size_ += computeStringSize(4, self.a);
  }
  if (self.hasACertHash) {
    size_ += computeStringSize(5, self.aCertHash);
  }
  if (self.hasDhGroupId) {
    size_ += computeUInt32Size(6, self.dhGroupId);
  }
  if (self.hasGx) {
    size_ += computeDataSize(7, self.gx);
  }
  if (self.hasGy) {
    size_ += computeDataSize(8, self.gy);
  }
  if (self.hasGxy) {
    size_ += computeDataSize(9, self.gxy);
  }
  if (self.hasNonce1) {
    size_ += computeStringSize(10, self.nonce1);
  }
  if (self.hasNonce2) {
    size_ += computeStringSize(11, self.nonce2);
  }
  if (self.hasNonceb) {
    size_ += computeDataSize(12, self.nonceb);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbUploadFileToMac*) parseFromData:(NSData*) data {
  return (PEXPbUploadFileToMac*)[[[PEXPbUploadFileToMac builder] mergeFromData:data] build];
}
+ (PEXPbUploadFileToMac*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileToMac*)[[[PEXPbUploadFileToMac builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileToMac*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbUploadFileToMac*)[[[PEXPbUploadFileToMac builder] mergeFromInputStream:input] build];
}
+ (PEXPbUploadFileToMac*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileToMac*)[[[PEXPbUploadFileToMac builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileToMac*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbUploadFileToMac*)[[[PEXPbUploadFileToMac builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbUploadFileToMac*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileToMac*)[[[PEXPbUploadFileToMac builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileToMacBuilder*) builder {
  return [[PEXPbUploadFileToMacBuilder alloc] init];
}
+ (PEXPbUploadFileToMacBuilder*) builderWithPrototype:(PEXPbUploadFileToMac*) prototype {
  return [[PEXPbUploadFileToMac builder] mergeFrom:prototype];
}
- (PEXPbUploadFileToMacBuilder*) builder {
  return [PEXPbUploadFileToMac builder];
}
- (PEXPbUploadFileToMacBuilder*) toBuilder {
  return [PEXPbUploadFileToMac builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasVersion) {
    [output appendFormat:@"%@%@: %@\n", indent, @"version", [NSNumber numberWithInteger:self.version]];
  }
  if (self.hasB) {
    [output appendFormat:@"%@%@: %@\n", indent, @"b", self.b];
  }
  if (self.hasBCertHash) {
    [output appendFormat:@"%@%@: %@\n", indent, @"bCertHash", self.bCertHash];
  }
  if (self.hasA) {
    [output appendFormat:@"%@%@: %@\n", indent, @"a", self.a];
  }
  if (self.hasACertHash) {
    [output appendFormat:@"%@%@: %@\n", indent, @"aCertHash", self.aCertHash];
  }
  if (self.hasDhGroupId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"dhGroupId", [NSNumber numberWithInteger:self.dhGroupId]];
  }
  if (self.hasGx) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gx", self.gx];
  }
  if (self.hasGy) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gy", self.gy];
  }
  if (self.hasGxy) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gxy", self.gxy];
  }
  if (self.hasNonce1) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonce1", self.nonce1];
  }
  if (self.hasNonce2) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonce2", self.nonce2];
  }
  if (self.hasNonceb) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonceb", self.nonceb];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbUploadFileToMac class]]) {
    return NO;
  }
  PEXPbUploadFileToMac *otherMessage = other;
  return
      self.hasVersion == otherMessage.hasVersion &&
      (!self.hasVersion || self.version == otherMessage.version) &&
      self.hasB == otherMessage.hasB &&
      (!self.hasB || [self.b isEqual:otherMessage.b]) &&
      self.hasBCertHash == otherMessage.hasBCertHash &&
      (!self.hasBCertHash || [self.bCertHash isEqual:otherMessage.bCertHash]) &&
      self.hasA == otherMessage.hasA &&
      (!self.hasA || [self.a isEqual:otherMessage.a]) &&
      self.hasACertHash == otherMessage.hasACertHash &&
      (!self.hasACertHash || [self.aCertHash isEqual:otherMessage.aCertHash]) &&
      self.hasDhGroupId == otherMessage.hasDhGroupId &&
      (!self.hasDhGroupId || self.dhGroupId == otherMessage.dhGroupId) &&
      self.hasGx == otherMessage.hasGx &&
      (!self.hasGx || [self.gx isEqual:otherMessage.gx]) &&
      self.hasGy == otherMessage.hasGy &&
      (!self.hasGy || [self.gy isEqual:otherMessage.gy]) &&
      self.hasGxy == otherMessage.hasGxy &&
      (!self.hasGxy || [self.gxy isEqual:otherMessage.gxy]) &&
      self.hasNonce1 == otherMessage.hasNonce1 &&
      (!self.hasNonce1 || [self.nonce1 isEqual:otherMessage.nonce1]) &&
      self.hasNonce2 == otherMessage.hasNonce2 &&
      (!self.hasNonce2 || [self.nonce2 isEqual:otherMessage.nonce2]) &&
      self.hasNonceb == otherMessage.hasNonceb &&
      (!self.hasNonceb || [self.nonceb isEqual:otherMessage.nonceb]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasVersion) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.version] hash];
  }
  if (self.hasB) {
    hashCode = hashCode * 31 + [self.b hash];
  }
  if (self.hasBCertHash) {
    hashCode = hashCode * 31 + [self.bCertHash hash];
  }
  if (self.hasA) {
    hashCode = hashCode * 31 + [self.a hash];
  }
  if (self.hasACertHash) {
    hashCode = hashCode * 31 + [self.aCertHash hash];
  }
  if (self.hasDhGroupId) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.dhGroupId] hash];
  }
  if (self.hasGx) {
    hashCode = hashCode * 31 + [self.gx hash];
  }
  if (self.hasGy) {
    hashCode = hashCode * 31 + [self.gy hash];
  }
  if (self.hasGxy) {
    hashCode = hashCode * 31 + [self.gxy hash];
  }
  if (self.hasNonce1) {
    hashCode = hashCode * 31 + [self.nonce1 hash];
  }
  if (self.hasNonce2) {
    hashCode = hashCode * 31 + [self.nonce2 hash];
  }
  if (self.hasNonceb) {
    hashCode = hashCode * 31 + [self.nonceb hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbUploadFileToMacBuilder()
@property (strong) PEXPbUploadFileToMac* result;
@end

@implementation PEXPbUploadFileToMacBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbUploadFileToMac alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbUploadFileToMacBuilder*) clear {
  self.result = [[PEXPbUploadFileToMac alloc] init];
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clone {
  return [PEXPbUploadFileToMac builderWithPrototype:result];
}
- (PEXPbUploadFileToMac*) defaultInstance {
  return [PEXPbUploadFileToMac defaultInstance];
}
- (PEXPbUploadFileToMac*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbUploadFileToMac*) buildPartial {
  PEXPbUploadFileToMac* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbUploadFileToMacBuilder*) mergeFrom:(PEXPbUploadFileToMac*) other {
  if (other == [PEXPbUploadFileToMac defaultInstance]) {
    return self;
  }
  if (other.hasVersion) {
    [self setVersion:other.version];
  }
  if (other.hasB) {
    [self setB:other.b];
  }
  if (other.hasBCertHash) {
    [self setBCertHash:other.bCertHash];
  }
  if (other.hasA) {
    [self setA:other.a];
  }
  if (other.hasACertHash) {
    [self setACertHash:other.aCertHash];
  }
  if (other.hasDhGroupId) {
    [self setDhGroupId:other.dhGroupId];
  }
  if (other.hasGx) {
    [self setGx:other.gx];
  }
  if (other.hasGy) {
    [self setGy:other.gy];
  }
  if (other.hasGxy) {
    [self setGxy:other.gxy];
  }
  if (other.hasNonce1) {
    [self setNonce1:other.nonce1];
  }
  if (other.hasNonce2) {
    [self setNonce2:other.nonce2];
  }
  if (other.hasNonceb) {
    [self setNonceb:other.nonceb];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbUploadFileToMacBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbUploadFileToMacBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setVersion:[input readUInt32]];
        break;
      }
      case 18: {
        [self setB:[input readString]];
        break;
      }
      case 26: {
        [self setBCertHash:[input readString]];
        break;
      }
      case 34: {
        [self setA:[input readString]];
        break;
      }
      case 42: {
        [self setACertHash:[input readString]];
        break;
      }
      case 48: {
        [self setDhGroupId:[input readUInt32]];
        break;
      }
      case 58: {
        [self setGx:[input readData]];
        break;
      }
      case 66: {
        [self setGy:[input readData]];
        break;
      }
      case 74: {
        [self setGxy:[input readData]];
        break;
      }
      case 82: {
        [self setNonce1:[input readString]];
        break;
      }
      case 90: {
        [self setNonce2:[input readString]];
        break;
      }
      case 98: {
        [self setNonceb:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasVersion {
  return result.hasVersion;
}
- (UInt32) version {
  return result.version;
}
- (PEXPbUploadFileToMacBuilder*) setVersion:(UInt32) value {
  result.hasVersion = YES;
  result.version = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearVersion {
  result.hasVersion = NO;
  result.version = 1;
  return self;
}
- (BOOL) hasB {
  return result.hasB;
}
- (NSString*) b {
  return result.b;
}
- (PEXPbUploadFileToMacBuilder*) setB:(NSString*) value {
  result.hasB = YES;
  result.b = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearB {
  result.hasB = NO;
  result.b = @"";
  return self;
}
- (BOOL) hasBCertHash {
  return result.hasBCertHash;
}
- (NSString*) bCertHash {
  return result.bCertHash;
}
- (PEXPbUploadFileToMacBuilder*) setBCertHash:(NSString*) value {
  result.hasBCertHash = YES;
  result.bCertHash = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearBCertHash {
  result.hasBCertHash = NO;
  result.bCertHash = @"";
  return self;
}
- (BOOL) hasA {
  return result.hasA;
}
- (NSString*) a {
  return result.a;
}
- (PEXPbUploadFileToMacBuilder*) setA:(NSString*) value {
  result.hasA = YES;
  result.a = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearA {
  result.hasA = NO;
  result.a = @"";
  return self;
}
- (BOOL) hasACertHash {
  return result.hasACertHash;
}
- (NSString*) aCertHash {
  return result.aCertHash;
}
- (PEXPbUploadFileToMacBuilder*) setACertHash:(NSString*) value {
  result.hasACertHash = YES;
  result.aCertHash = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearACertHash {
  result.hasACertHash = NO;
  result.aCertHash = @"";
  return self;
}
- (BOOL) hasDhGroupId {
  return result.hasDhGroupId;
}
- (UInt32) dhGroupId {
  return result.dhGroupId;
}
- (PEXPbUploadFileToMacBuilder*) setDhGroupId:(UInt32) value {
  result.hasDhGroupId = YES;
  result.dhGroupId = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearDhGroupId {
  result.hasDhGroupId = NO;
  result.dhGroupId = 0;
  return self;
}
- (BOOL) hasGx {
  return result.hasGx;
}
- (NSData*) gx {
  return result.gx;
}
- (PEXPbUploadFileToMacBuilder*) setGx:(NSData*) value {
  result.hasGx = YES;
  result.gx = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearGx {
  result.hasGx = NO;
  result.gx = [NSData data];
  return self;
}
- (BOOL) hasGy {
  return result.hasGy;
}
- (NSData*) gy {
  return result.gy;
}
- (PEXPbUploadFileToMacBuilder*) setGy:(NSData*) value {
  result.hasGy = YES;
  result.gy = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearGy {
  result.hasGy = NO;
  result.gy = [NSData data];
  return self;
}
- (BOOL) hasGxy {
  return result.hasGxy;
}
- (NSData*) gxy {
  return result.gxy;
}
- (PEXPbUploadFileToMacBuilder*) setGxy:(NSData*) value {
  result.hasGxy = YES;
  result.gxy = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearGxy {
  result.hasGxy = NO;
  result.gxy = [NSData data];
  return self;
}
- (BOOL) hasNonce1 {
  return result.hasNonce1;
}
- (NSString*) nonce1 {
  return result.nonce1;
}
- (PEXPbUploadFileToMacBuilder*) setNonce1:(NSString*) value {
  result.hasNonce1 = YES;
  result.nonce1 = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearNonce1 {
  result.hasNonce1 = NO;
  result.nonce1 = @"";
  return self;
}
- (BOOL) hasNonce2 {
  return result.hasNonce2;
}
- (NSString*) nonce2 {
  return result.nonce2;
}
- (PEXPbUploadFileToMacBuilder*) setNonce2:(NSString*) value {
  result.hasNonce2 = YES;
  result.nonce2 = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearNonce2 {
  result.hasNonce2 = NO;
  result.nonce2 = @"";
  return self;
}
- (BOOL) hasNonceb {
  return result.hasNonceb;
}
- (NSData*) nonceb {
  return result.nonceb;
}
- (PEXPbUploadFileToMacBuilder*) setNonceb:(NSData*) value {
  result.hasNonceb = YES;
  result.nonceb = value;
  return self;
}
- (PEXPbUploadFileToMacBuilder*) clearNonceb {
  result.hasNonceb = NO;
  result.nonceb = [NSData data];
  return self;
}
@end

@interface PEXPbUploadFileXb ()
@property (strong) NSString* b;
@property (strong) NSData* nonceb;
@property (strong) NSData* sig;
@end

@implementation PEXPbUploadFileXb

- (BOOL) hasB {
  return !!hasB_;
}
- (void) setHasB:(BOOL) value_ {
  hasB_ = !!value_;
}
@synthesize b;
- (BOOL) hasNonceb {
  return !!hasNonceb_;
}
- (void) setHasNonceb:(BOOL) value_ {
  hasNonceb_ = !!value_;
}
@synthesize nonceb;
- (BOOL) hasSig {
  return !!hasSig_;
}
- (void) setHasSig:(BOOL) value_ {
  hasSig_ = !!value_;
}
@synthesize sig;
- (id) init {
  if ((self = [super init])) {
    self.b = @"";
    self.nonceb = [NSData data];
    self.sig = [NSData data];
  }
  return self;
}
static PEXPbUploadFileXb* defaultPEXPbUploadFileXbInstance = nil;
+ (void) initialize {
  if (self == [PEXPbUploadFileXb class]) {
    defaultPEXPbUploadFileXbInstance = [[PEXPbUploadFileXb alloc] init];
  }
}
+ (PEXPbUploadFileXb*) defaultInstance {
  return defaultPEXPbUploadFileXbInstance;
}
- (PEXPbUploadFileXb*) defaultInstance {
  return defaultPEXPbUploadFileXbInstance;
}
- (BOOL) isInitialized {
  if (!self.hasB) {
    return NO;
  }
  if (!self.hasNonceb) {
    return NO;
  }
  if (!self.hasSig) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasB) {
    [output writeString:1 value:self.b];
  }
  if (self.hasNonceb) {
    [output writeData:2 value:self.nonceb];
  }
  if (self.hasSig) {
    [output writeData:3 value:self.sig];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasB) {
    size_ += computeStringSize(1, self.b);
  }
  if (self.hasNonceb) {
    size_ += computeDataSize(2, self.nonceb);
  }
  if (self.hasSig) {
    size_ += computeDataSize(3, self.sig);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbUploadFileXb*) parseFromData:(NSData*) data {
  return (PEXPbUploadFileXb*)[[[PEXPbUploadFileXb builder] mergeFromData:data] build];
}
+ (PEXPbUploadFileXb*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileXb*)[[[PEXPbUploadFileXb builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileXb*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbUploadFileXb*)[[[PEXPbUploadFileXb builder] mergeFromInputStream:input] build];
}
+ (PEXPbUploadFileXb*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileXb*)[[[PEXPbUploadFileXb builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileXb*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbUploadFileXb*)[[[PEXPbUploadFileXb builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbUploadFileXb*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileXb*)[[[PEXPbUploadFileXb builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileXbBuilder*) builder {
  return [[PEXPbUploadFileXbBuilder alloc] init];
}
+ (PEXPbUploadFileXbBuilder*) builderWithPrototype:(PEXPbUploadFileXb*) prototype {
  return [[PEXPbUploadFileXb builder] mergeFrom:prototype];
}
- (PEXPbUploadFileXbBuilder*) builder {
  return [PEXPbUploadFileXb builder];
}
- (PEXPbUploadFileXbBuilder*) toBuilder {
  return [PEXPbUploadFileXb builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasB) {
    [output appendFormat:@"%@%@: %@\n", indent, @"b", self.b];
  }
  if (self.hasNonceb) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonceb", self.nonceb];
  }
  if (self.hasSig) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sig", self.sig];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbUploadFileXb class]]) {
    return NO;
  }
  PEXPbUploadFileXb *otherMessage = other;
  return
      self.hasB == otherMessage.hasB &&
      (!self.hasB || [self.b isEqual:otherMessage.b]) &&
      self.hasNonceb == otherMessage.hasNonceb &&
      (!self.hasNonceb || [self.nonceb isEqual:otherMessage.nonceb]) &&
      self.hasSig == otherMessage.hasSig &&
      (!self.hasSig || [self.sig isEqual:otherMessage.sig]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasB) {
    hashCode = hashCode * 31 + [self.b hash];
  }
  if (self.hasNonceb) {
    hashCode = hashCode * 31 + [self.nonceb hash];
  }
  if (self.hasSig) {
    hashCode = hashCode * 31 + [self.sig hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbUploadFileXbBuilder()
@property (strong) PEXPbUploadFileXb* result;
@end

@implementation PEXPbUploadFileXbBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbUploadFileXb alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbUploadFileXbBuilder*) clear {
  self.result = [[PEXPbUploadFileXb alloc] init];
  return self;
}
- (PEXPbUploadFileXbBuilder*) clone {
  return [PEXPbUploadFileXb builderWithPrototype:result];
}
- (PEXPbUploadFileXb*) defaultInstance {
  return [PEXPbUploadFileXb defaultInstance];
}
- (PEXPbUploadFileXb*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbUploadFileXb*) buildPartial {
  PEXPbUploadFileXb* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbUploadFileXbBuilder*) mergeFrom:(PEXPbUploadFileXb*) other {
  if (other == [PEXPbUploadFileXb defaultInstance]) {
    return self;
  }
  if (other.hasB) {
    [self setB:other.b];
  }
  if (other.hasNonceb) {
    [self setNonceb:other.nonceb];
  }
  if (other.hasSig) {
    [self setSig:other.sig];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbUploadFileXbBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbUploadFileXbBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setB:[input readString]];
        break;
      }
      case 18: {
        [self setNonceb:[input readData]];
        break;
      }
      case 26: {
        [self setSig:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasB {
  return result.hasB;
}
- (NSString*) b {
  return result.b;
}
- (PEXPbUploadFileXbBuilder*) setB:(NSString*) value {
  result.hasB = YES;
  result.b = value;
  return self;
}
- (PEXPbUploadFileXbBuilder*) clearB {
  result.hasB = NO;
  result.b = @"";
  return self;
}
- (BOOL) hasNonceb {
  return result.hasNonceb;
}
- (NSData*) nonceb {
  return result.nonceb;
}
- (PEXPbUploadFileXbBuilder*) setNonceb:(NSData*) value {
  result.hasNonceb = YES;
  result.nonceb = value;
  return self;
}
- (PEXPbUploadFileXbBuilder*) clearNonceb {
  result.hasNonceb = NO;
  result.nonceb = [NSData data];
  return self;
}
- (BOOL) hasSig {
  return result.hasSig;
}
- (NSData*) sig {
  return result.sig;
}
- (PEXPbUploadFileXbBuilder*) setSig:(NSData*) value {
  result.hasSig = YES;
  result.sig = value;
  return self;
}
- (PEXPbUploadFileXbBuilder*) clearSig {
  result.hasSig = NO;
  result.sig = [NSData data];
  return self;
}
@end

@interface PEXPbUploadFileEncryptionInfo ()
@property (strong) NSData* iv;
@property (strong) NSData* mac;
@end

@implementation PEXPbUploadFileEncryptionInfo

- (BOOL) hasIv {
  return !!hasIv_;
}
- (void) setHasIv:(BOOL) value_ {
  hasIv_ = !!value_;
}
@synthesize iv;
- (BOOL) hasMac {
  return !!hasMac_;
}
- (void) setHasMac:(BOOL) value_ {
  hasMac_ = !!value_;
}
@synthesize mac;
- (id) init {
  if ((self = [super init])) {
    self.iv = [NSData data];
    self.mac = [NSData data];
  }
  return self;
}
static PEXPbUploadFileEncryptionInfo* defaultPEXPbUploadFileEncryptionInfoInstance = nil;
+ (void) initialize {
  if (self == [PEXPbUploadFileEncryptionInfo class]) {
    defaultPEXPbUploadFileEncryptionInfoInstance = [[PEXPbUploadFileEncryptionInfo alloc] init];
  }
}
+ (PEXPbUploadFileEncryptionInfo*) defaultInstance {
  return defaultPEXPbUploadFileEncryptionInfoInstance;
}
- (PEXPbUploadFileEncryptionInfo*) defaultInstance {
  return defaultPEXPbUploadFileEncryptionInfoInstance;
}
- (BOOL) isInitialized {
  if (!self.hasIv) {
    return NO;
  }
  if (!self.hasMac) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasIv) {
    [output writeData:1 value:self.iv];
  }
  if (self.hasMac) {
    [output writeData:2 value:self.mac];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasIv) {
    size_ += computeDataSize(1, self.iv);
  }
  if (self.hasMac) {
    size_ += computeDataSize(2, self.mac);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbUploadFileEncryptionInfo*) parseFromData:(NSData*) data {
  return (PEXPbUploadFileEncryptionInfo*)[[[PEXPbUploadFileEncryptionInfo builder] mergeFromData:data] build];
}
+ (PEXPbUploadFileEncryptionInfo*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileEncryptionInfo*)[[[PEXPbUploadFileEncryptionInfo builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileEncryptionInfo*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbUploadFileEncryptionInfo*)[[[PEXPbUploadFileEncryptionInfo builder] mergeFromInputStream:input] build];
}
+ (PEXPbUploadFileEncryptionInfo*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileEncryptionInfo*)[[[PEXPbUploadFileEncryptionInfo builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileEncryptionInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbUploadFileEncryptionInfo*)[[[PEXPbUploadFileEncryptionInfo builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbUploadFileEncryptionInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbUploadFileEncryptionInfo*)[[[PEXPbUploadFileEncryptionInfo builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbUploadFileEncryptionInfoBuilder*) builder {
  return [[PEXPbUploadFileEncryptionInfoBuilder alloc] init];
}
+ (PEXPbUploadFileEncryptionInfoBuilder*) builderWithPrototype:(PEXPbUploadFileEncryptionInfo*) prototype {
  return [[PEXPbUploadFileEncryptionInfo builder] mergeFrom:prototype];
}
- (PEXPbUploadFileEncryptionInfoBuilder*) builder {
  return [PEXPbUploadFileEncryptionInfo builder];
}
- (PEXPbUploadFileEncryptionInfoBuilder*) toBuilder {
  return [PEXPbUploadFileEncryptionInfo builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasIv) {
    [output appendFormat:@"%@%@: %@\n", indent, @"iv", self.iv];
  }
  if (self.hasMac) {
    [output appendFormat:@"%@%@: %@\n", indent, @"mac", self.mac];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbUploadFileEncryptionInfo class]]) {
    return NO;
  }
  PEXPbUploadFileEncryptionInfo *otherMessage = other;
  return
      self.hasIv == otherMessage.hasIv &&
      (!self.hasIv || [self.iv isEqual:otherMessage.iv]) &&
      self.hasMac == otherMessage.hasMac &&
      (!self.hasMac || [self.mac isEqual:otherMessage.mac]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasIv) {
    hashCode = hashCode * 31 + [self.iv hash];
  }
  if (self.hasMac) {
    hashCode = hashCode * 31 + [self.mac hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbUploadFileEncryptionInfoBuilder()
@property (strong) PEXPbUploadFileEncryptionInfo* result;
@end

@implementation PEXPbUploadFileEncryptionInfoBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbUploadFileEncryptionInfo alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) clear {
  self.result = [[PEXPbUploadFileEncryptionInfo alloc] init];
  return self;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) clone {
  return [PEXPbUploadFileEncryptionInfo builderWithPrototype:result];
}
- (PEXPbUploadFileEncryptionInfo*) defaultInstance {
  return [PEXPbUploadFileEncryptionInfo defaultInstance];
}
- (PEXPbUploadFileEncryptionInfo*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbUploadFileEncryptionInfo*) buildPartial {
  PEXPbUploadFileEncryptionInfo* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) mergeFrom:(PEXPbUploadFileEncryptionInfo*) other {
  if (other == [PEXPbUploadFileEncryptionInfo defaultInstance]) {
    return self;
  }
  if (other.hasIv) {
    [self setIv:other.iv];
  }
  if (other.hasMac) {
    [self setMac:other.mac];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbUploadFileEncryptionInfoBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setIv:[input readData]];
        break;
      }
      case 18: {
        [self setMac:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasIv {
  return result.hasIv;
}
- (NSData*) iv {
  return result.iv;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) setIv:(NSData*) value {
  result.hasIv = YES;
  result.iv = value;
  return self;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) clearIv {
  result.hasIv = NO;
  result.iv = [NSData data];
  return self;
}
- (BOOL) hasMac {
  return result.hasMac;
}
- (NSData*) mac {
  return result.mac;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) setMac:(NSData*) value {
  result.hasMac = YES;
  result.mac = value;
  return self;
}
- (PEXPbUploadFileEncryptionInfoBuilder*) clearMac {
  result.hasMac = NO;
  result.mac = [NSData data];
  return self;
}
@end

@interface PEXPbMetaFileDetail ()
@property (strong) NSString* fileName;
@property (strong) NSString* extension;
@property (strong) NSString* mimeType;
@property UInt64 fileSize;
@property (strong) NSData* xhash;
@property (strong) NSData* thumb;
@property SInt32 prefOrder;
@property (strong) NSString* thumbNameInZip;
@property (strong) NSString* title;
@property (strong) NSString* desc;
@property UInt64 fileTimeMilli;
@end

@implementation PEXPbMetaFileDetail

- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value_ {
  hasFileName_ = !!value_;
}
@synthesize fileName;
- (BOOL) hasExtension {
  return !!hasExtension_;
}
- (void) setHasExtension:(BOOL) value_ {
  hasExtension_ = !!value_;
}
@synthesize extension;
- (BOOL) hasMimeType {
  return !!hasMimeType_;
}
- (void) setHasMimeType:(BOOL) value_ {
  hasMimeType_ = !!value_;
}
@synthesize mimeType;
- (BOOL) hasFileSize {
  return !!hasFileSize_;
}
- (void) setHasFileSize:(BOOL) value_ {
  hasFileSize_ = !!value_;
}
@synthesize fileSize;
- (BOOL) hasXhash {
  return !!hasXhash_;
}
- (void) setHasXhash:(BOOL) value_ {
  hasXhash_ = !!value_;
}
@synthesize xhash;
- (BOOL) hasThumb {
  return !!hasThumb_;
}
- (void) setHasThumb:(BOOL) value_ {
  hasThumb_ = !!value_;
}
@synthesize thumb;
- (BOOL) hasPrefOrder {
  return !!hasPrefOrder_;
}
- (void) setHasPrefOrder:(BOOL) value_ {
  hasPrefOrder_ = !!value_;
}
@synthesize prefOrder;
- (BOOL) hasThumbNameInZip {
  return !!hasThumbNameInZip_;
}
- (void) setHasThumbNameInZip:(BOOL) value_ {
  hasThumbNameInZip_ = !!value_;
}
@synthesize thumbNameInZip;
- (BOOL) hasTitle {
  return !!hasTitle_;
}
- (void) setHasTitle:(BOOL) value_ {
  hasTitle_ = !!value_;
}
@synthesize title;
- (BOOL) hasDesc {
  return !!hasDesc_;
}
- (void) setHasDesc:(BOOL) value_ {
  hasDesc_ = !!value_;
}
@synthesize desc;
- (BOOL) hasFileTimeMilli {
  return !!hasFileTimeMilli_;
}
- (void) setHasFileTimeMilli:(BOOL) value_ {
  hasFileTimeMilli_ = !!value_;
}
@synthesize fileTimeMilli;
- (id) init {
  if ((self = [super init])) {
    self.fileName = @"";
    self.extension = @"";
    self.mimeType = @"";
    self.fileSize = 0L;
    self.xhash = [NSData data];
    self.thumb = [NSData data];
    self.prefOrder = 0;
    self.thumbNameInZip = @"";
    self.title = @"";
    self.desc = @"";
    self.fileTimeMilli = 0L;
  }
  return self;
}
static PEXPbMetaFileDetail* defaultPEXPbMetaFileDetailInstance = nil;
+ (void) initialize {
  if (self == [PEXPbMetaFileDetail class]) {
    defaultPEXPbMetaFileDetailInstance = [[PEXPbMetaFileDetail alloc] init];
  }
}
+ (PEXPbMetaFileDetail*) defaultInstance {
  return defaultPEXPbMetaFileDetailInstance;
}
- (PEXPbMetaFileDetail*) defaultInstance {
  return defaultPEXPbMetaFileDetailInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileName) {
    [output writeString:1 value:self.fileName];
  }
  if (self.hasExtension) {
    [output writeString:2 value:self.extension];
  }
  if (self.hasMimeType) {
    [output writeString:3 value:self.mimeType];
  }
  if (self.hasFileSize) {
    [output writeUInt64:4 value:self.fileSize];
  }
  if (self.hasXhash) {
    [output writeData:5 value:self.xhash];
  }
  if (self.hasThumb) {
    [output writeData:6 value:self.thumb];
  }
  if (self.hasPrefOrder) {
    [output writeInt32:7 value:self.prefOrder];
  }
  if (self.hasThumbNameInZip) {
    [output writeString:8 value:self.thumbNameInZip];
  }
  if (self.hasTitle) {
    [output writeString:9 value:self.title];
  }
  if (self.hasDesc) {
    [output writeString:10 value:self.desc];
  }
  if (self.hasFileTimeMilli) {
    [output writeUInt64:11 value:self.fileTimeMilli];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasFileName) {
    size_ += computeStringSize(1, self.fileName);
  }
  if (self.hasExtension) {
    size_ += computeStringSize(2, self.extension);
  }
  if (self.hasMimeType) {
    size_ += computeStringSize(3, self.mimeType);
  }
  if (self.hasFileSize) {
    size_ += computeUInt64Size(4, self.fileSize);
  }
  if (self.hasXhash) {
    size_ += computeDataSize(5, self.xhash);
  }
  if (self.hasThumb) {
    size_ += computeDataSize(6, self.thumb);
  }
  if (self.hasPrefOrder) {
    size_ += computeInt32Size(7, self.prefOrder);
  }
  if (self.hasThumbNameInZip) {
    size_ += computeStringSize(8, self.thumbNameInZip);
  }
  if (self.hasTitle) {
    size_ += computeStringSize(9, self.title);
  }
  if (self.hasDesc) {
    size_ += computeStringSize(10, self.desc);
  }
  if (self.hasFileTimeMilli) {
    size_ += computeUInt64Size(11, self.fileTimeMilli);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbMetaFileDetail*) parseFromData:(NSData*) data {
  return (PEXPbMetaFileDetail*)[[[PEXPbMetaFileDetail builder] mergeFromData:data] build];
}
+ (PEXPbMetaFileDetail*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMetaFileDetail*)[[[PEXPbMetaFileDetail builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMetaFileDetail*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbMetaFileDetail*)[[[PEXPbMetaFileDetail builder] mergeFromInputStream:input] build];
}
+ (PEXPbMetaFileDetail*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMetaFileDetail*)[[[PEXPbMetaFileDetail builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMetaFileDetail*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbMetaFileDetail*)[[[PEXPbMetaFileDetail builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbMetaFileDetail*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMetaFileDetail*)[[[PEXPbMetaFileDetail builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMetaFileDetailBuilder*) builder {
  return [[PEXPbMetaFileDetailBuilder alloc] init];
}
+ (PEXPbMetaFileDetailBuilder*) builderWithPrototype:(PEXPbMetaFileDetail*) prototype {
  return [[PEXPbMetaFileDetail builder] mergeFrom:prototype];
}
- (PEXPbMetaFileDetailBuilder*) builder {
  return [PEXPbMetaFileDetail builder];
}
- (PEXPbMetaFileDetailBuilder*) toBuilder {
  return [PEXPbMetaFileDetail builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasFileName) {
    [output appendFormat:@"%@%@: %@\n", indent, @"fileName", self.fileName];
  }
  if (self.hasExtension) {
    [output appendFormat:@"%@%@: %@\n", indent, @"extension", self.extension];
  }
  if (self.hasMimeType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"mimeType", self.mimeType];
  }
  if (self.hasFileSize) {
    [output appendFormat:@"%@%@: %@\n", indent, @"fileSize", [NSNumber numberWithLongLong:self.fileSize]];
  }
  if (self.hasXhash) {
    [output appendFormat:@"%@%@: %@\n", indent, @"xhash", self.xhash];
  }
  if (self.hasThumb) {
    [output appendFormat:@"%@%@: %@\n", indent, @"thumb", self.thumb];
  }
  if (self.hasPrefOrder) {
    [output appendFormat:@"%@%@: %@\n", indent, @"prefOrder", [NSNumber numberWithInteger:self.prefOrder]];
  }
  if (self.hasThumbNameInZip) {
    [output appendFormat:@"%@%@: %@\n", indent, @"thumbNameInZip", self.thumbNameInZip];
  }
  if (self.hasTitle) {
    [output appendFormat:@"%@%@: %@\n", indent, @"title", self.title];
  }
  if (self.hasDesc) {
    [output appendFormat:@"%@%@: %@\n", indent, @"desc", self.desc];
  }
  if (self.hasFileTimeMilli) {
    [output appendFormat:@"%@%@: %@\n", indent, @"fileTimeMilli", [NSNumber numberWithLongLong:self.fileTimeMilli]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbMetaFileDetail class]]) {
    return NO;
  }
  PEXPbMetaFileDetail *otherMessage = other;
  return
      self.hasFileName == otherMessage.hasFileName &&
      (!self.hasFileName || [self.fileName isEqual:otherMessage.fileName]) &&
      self.hasExtension == otherMessage.hasExtension &&
      (!self.hasExtension || [self.extension isEqual:otherMessage.extension]) &&
      self.hasMimeType == otherMessage.hasMimeType &&
      (!self.hasMimeType || [self.mimeType isEqual:otherMessage.mimeType]) &&
      self.hasFileSize == otherMessage.hasFileSize &&
      (!self.hasFileSize || self.fileSize == otherMessage.fileSize) &&
      self.hasXhash == otherMessage.hasXhash &&
      (!self.hasXhash || [self.xhash isEqual:otherMessage.xhash]) &&
      self.hasThumb == otherMessage.hasThumb &&
      (!self.hasThumb || [self.thumb isEqual:otherMessage.thumb]) &&
      self.hasPrefOrder == otherMessage.hasPrefOrder &&
      (!self.hasPrefOrder || self.prefOrder == otherMessage.prefOrder) &&
      self.hasThumbNameInZip == otherMessage.hasThumbNameInZip &&
      (!self.hasThumbNameInZip || [self.thumbNameInZip isEqual:otherMessage.thumbNameInZip]) &&
      self.hasTitle == otherMessage.hasTitle &&
      (!self.hasTitle || [self.title isEqual:otherMessage.title]) &&
      self.hasDesc == otherMessage.hasDesc &&
      (!self.hasDesc || [self.desc isEqual:otherMessage.desc]) &&
      self.hasFileTimeMilli == otherMessage.hasFileTimeMilli &&
      (!self.hasFileTimeMilli || self.fileTimeMilli == otherMessage.fileTimeMilli) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasFileName) {
    hashCode = hashCode * 31 + [self.fileName hash];
  }
  if (self.hasExtension) {
    hashCode = hashCode * 31 + [self.extension hash];
  }
  if (self.hasMimeType) {
    hashCode = hashCode * 31 + [self.mimeType hash];
  }
  if (self.hasFileSize) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.fileSize] hash];
  }
  if (self.hasXhash) {
    hashCode = hashCode * 31 + [self.xhash hash];
  }
  if (self.hasThumb) {
    hashCode = hashCode * 31 + [self.thumb hash];
  }
  if (self.hasPrefOrder) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.prefOrder] hash];
  }
  if (self.hasThumbNameInZip) {
    hashCode = hashCode * 31 + [self.thumbNameInZip hash];
  }
  if (self.hasTitle) {
    hashCode = hashCode * 31 + [self.title hash];
  }
  if (self.hasDesc) {
    hashCode = hashCode * 31 + [self.desc hash];
  }
  if (self.hasFileTimeMilli) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.fileTimeMilli] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbMetaFileDetailBuilder()
@property (strong) PEXPbMetaFileDetail* result;
@end

@implementation PEXPbMetaFileDetailBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbMetaFileDetail alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbMetaFileDetailBuilder*) clear {
  self.result = [[PEXPbMetaFileDetail alloc] init];
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clone {
  return [PEXPbMetaFileDetail builderWithPrototype:result];
}
- (PEXPbMetaFileDetail*) defaultInstance {
  return [PEXPbMetaFileDetail defaultInstance];
}
- (PEXPbMetaFileDetail*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbMetaFileDetail*) buildPartial {
  PEXPbMetaFileDetail* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbMetaFileDetailBuilder*) mergeFrom:(PEXPbMetaFileDetail*) other {
  if (other == [PEXPbMetaFileDetail defaultInstance]) {
    return self;
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasExtension) {
    [self setExtension:other.extension];
  }
  if (other.hasMimeType) {
    [self setMimeType:other.mimeType];
  }
  if (other.hasFileSize) {
    [self setFileSize:other.fileSize];
  }
  if (other.hasXhash) {
    [self setXhash:other.xhash];
  }
  if (other.hasThumb) {
    [self setThumb:other.thumb];
  }
  if (other.hasPrefOrder) {
    [self setPrefOrder:other.prefOrder];
  }
  if (other.hasThumbNameInZip) {
    [self setThumbNameInZip:other.thumbNameInZip];
  }
  if (other.hasTitle) {
    [self setTitle:other.title];
  }
  if (other.hasDesc) {
    [self setDesc:other.desc];
  }
  if (other.hasFileTimeMilli) {
    [self setFileTimeMilli:other.fileTimeMilli];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbMetaFileDetailBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbMetaFileDetailBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileName:[input readString]];
        break;
      }
      case 18: {
        [self setExtension:[input readString]];
        break;
      }
      case 26: {
        [self setMimeType:[input readString]];
        break;
      }
      case 32: {
        [self setFileSize:[input readUInt64]];
        break;
      }
      case 42: {
        [self setXhash:[input readData]];
        break;
      }
      case 50: {
        [self setThumb:[input readData]];
        break;
      }
      case 56: {
        [self setPrefOrder:[input readInt32]];
        break;
      }
      case 66: {
        [self setThumbNameInZip:[input readString]];
        break;
      }
      case 74: {
        [self setTitle:[input readString]];
        break;
      }
      case 82: {
        [self setDesc:[input readString]];
        break;
      }
      case 88: {
        [self setFileTimeMilli:[input readUInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSString*) fileName {
  return result.fileName;
}
- (PEXPbMetaFileDetailBuilder*) setFileName:(NSString*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = @"";
  return self;
}
- (BOOL) hasExtension {
  return result.hasExtension;
}
- (NSString*) extension {
  return result.extension;
}
- (PEXPbMetaFileDetailBuilder*) setExtension:(NSString*) value {
  result.hasExtension = YES;
  result.extension = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearExtension {
  result.hasExtension = NO;
  result.extension = @"";
  return self;
}
- (BOOL) hasMimeType {
  return result.hasMimeType;
}
- (NSString*) mimeType {
  return result.mimeType;
}
- (PEXPbMetaFileDetailBuilder*) setMimeType:(NSString*) value {
  result.hasMimeType = YES;
  result.mimeType = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearMimeType {
  result.hasMimeType = NO;
  result.mimeType = @"";
  return self;
}
- (BOOL) hasFileSize {
  return result.hasFileSize;
}
- (UInt64) fileSize {
  return result.fileSize;
}
- (PEXPbMetaFileDetailBuilder*) setFileSize:(UInt64) value {
  result.hasFileSize = YES;
  result.fileSize = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearFileSize {
  result.hasFileSize = NO;
  result.fileSize = 0L;
  return self;
}
- (BOOL) hasXhash {
  return result.hasXhash;
}
- (NSData*) xhash {
  return result.xhash;
}
- (PEXPbMetaFileDetailBuilder*) setXhash:(NSData*) value {
  result.hasXhash = YES;
  result.xhash = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearXhash {
  result.hasXhash = NO;
  result.xhash = [NSData data];
  return self;
}
- (BOOL) hasThumb {
  return result.hasThumb;
}
- (NSData*) thumb {
  return result.thumb;
}
- (PEXPbMetaFileDetailBuilder*) setThumb:(NSData*) value {
  result.hasThumb = YES;
  result.thumb = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearThumb {
  result.hasThumb = NO;
  result.thumb = [NSData data];
  return self;
}
- (BOOL) hasPrefOrder {
  return result.hasPrefOrder;
}
- (SInt32) prefOrder {
  return result.prefOrder;
}
- (PEXPbMetaFileDetailBuilder*) setPrefOrder:(SInt32) value {
  result.hasPrefOrder = YES;
  result.prefOrder = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearPrefOrder {
  result.hasPrefOrder = NO;
  result.prefOrder = 0;
  return self;
}
- (BOOL) hasThumbNameInZip {
  return result.hasThumbNameInZip;
}
- (NSString*) thumbNameInZip {
  return result.thumbNameInZip;
}
- (PEXPbMetaFileDetailBuilder*) setThumbNameInZip:(NSString*) value {
  result.hasThumbNameInZip = YES;
  result.thumbNameInZip = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearThumbNameInZip {
  result.hasThumbNameInZip = NO;
  result.thumbNameInZip = @"";
  return self;
}
- (BOOL) hasTitle {
  return result.hasTitle;
}
- (NSString*) title {
  return result.title;
}
- (PEXPbMetaFileDetailBuilder*) setTitle:(NSString*) value {
  result.hasTitle = YES;
  result.title = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearTitle {
  result.hasTitle = NO;
  result.title = @"";
  return self;
}
- (BOOL) hasDesc {
  return result.hasDesc;
}
- (NSString*) desc {
  return result.desc;
}
- (PEXPbMetaFileDetailBuilder*) setDesc:(NSString*) value {
  result.hasDesc = YES;
  result.desc = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearDesc {
  result.hasDesc = NO;
  result.desc = @"";
  return self;
}
- (BOOL) hasFileTimeMilli {
  return result.hasFileTimeMilli;
}
- (UInt64) fileTimeMilli {
  return result.fileTimeMilli;
}
- (PEXPbMetaFileDetailBuilder*) setFileTimeMilli:(UInt64) value {
  result.hasFileTimeMilli = YES;
  result.fileTimeMilli = value;
  return self;
}
- (PEXPbMetaFileDetailBuilder*) clearFileTimeMilli {
  result.hasFileTimeMilli = NO;
  result.fileTimeMilli = 0L;
  return self;
}
@end

@interface PEXPbMetaFile ()
@property UInt64 timestamp;
@property (strong) NSData* archiveHash;
@property (strong) NSData* archiveSig;
@property UInt32 numberOfFiles;
@property (strong) NSString* title;
@property (strong) NSString* xdescription;
@property (strong) NSMutableArray * filesArray;
@end

@implementation PEXPbMetaFile

- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value_ {
  hasTimestamp_ = !!value_;
}
@synthesize timestamp;
- (BOOL) hasArchiveHash {
  return !!hasArchiveHash_;
}
- (void) setHasArchiveHash:(BOOL) value_ {
  hasArchiveHash_ = !!value_;
}
@synthesize archiveHash;
- (BOOL) hasArchiveSig {
  return !!hasArchiveSig_;
}
- (void) setHasArchiveSig:(BOOL) value_ {
  hasArchiveSig_ = !!value_;
}
@synthesize archiveSig;
- (BOOL) hasNumberOfFiles {
  return !!hasNumberOfFiles_;
}
- (void) setHasNumberOfFiles:(BOOL) value_ {
  hasNumberOfFiles_ = !!value_;
}
@synthesize numberOfFiles;
- (BOOL) hasTitle {
  return !!hasTitle_;
}
- (void) setHasTitle:(BOOL) value_ {
  hasTitle_ = !!value_;
}
@synthesize title;
- (BOOL) hasXdescription {
  return !!hasXdescription_;
}
- (void) setHasXdescription:(BOOL) value_ {
  hasXdescription_ = !!value_;
}
@synthesize xdescription;
@synthesize filesArray;
@dynamic files;
- (id) init {
  if ((self = [super init])) {
    self.timestamp = 0L;
    self.archiveHash = [NSData data];
    self.archiveSig = [NSData data];
    self.numberOfFiles = 0;
    self.title = @"";
    self.xdescription = @"";
  }
  return self;
}
static PEXPbMetaFile* defaultPEXPbMetaFileInstance = nil;
+ (void) initialize {
  if (self == [PEXPbMetaFile class]) {
    defaultPEXPbMetaFileInstance = [[PEXPbMetaFile alloc] init];
  }
}
+ (PEXPbMetaFile*) defaultInstance {
  return defaultPEXPbMetaFileInstance;
}
- (PEXPbMetaFile*) defaultInstance {
  return defaultPEXPbMetaFileInstance;
}
- (NSArray *)files {
  return filesArray;
}
- (PEXPbMetaFileDetail*)filesAtIndex:(NSUInteger)index {
  return [filesArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasTimestamp) {
    [output writeUInt64:1 value:self.timestamp];
  }
  if (self.hasArchiveHash) {
    [output writeData:2 value:self.archiveHash];
  }
  if (self.hasArchiveSig) {
    [output writeData:3 value:self.archiveSig];
  }
  if (self.hasNumberOfFiles) {
    [output writeUInt32:4 value:self.numberOfFiles];
  }
  if (self.hasTitle) {
    [output writeString:5 value:self.title];
  }
  if (self.hasXdescription) {
    [output writeString:6 value:self.xdescription];
  }
  [self.filesArray enumerateObjectsUsingBlock:^(PEXPbMetaFileDetail *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:7 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasTimestamp) {
    size_ += computeUInt64Size(1, self.timestamp);
  }
  if (self.hasArchiveHash) {
    size_ += computeDataSize(2, self.archiveHash);
  }
  if (self.hasArchiveSig) {
    size_ += computeDataSize(3, self.archiveSig);
  }
  if (self.hasNumberOfFiles) {
    size_ += computeUInt32Size(4, self.numberOfFiles);
  }
  if (self.hasTitle) {
    size_ += computeStringSize(5, self.title);
  }
  if (self.hasXdescription) {
    size_ += computeStringSize(6, self.xdescription);
  }
  [self.filesArray enumerateObjectsUsingBlock:^(PEXPbMetaFileDetail *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(7, element);
  }];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbMetaFile*) parseFromData:(NSData*) data {
  return (PEXPbMetaFile*)[[[PEXPbMetaFile builder] mergeFromData:data] build];
}
+ (PEXPbMetaFile*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMetaFile*)[[[PEXPbMetaFile builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMetaFile*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbMetaFile*)[[[PEXPbMetaFile builder] mergeFromInputStream:input] build];
}
+ (PEXPbMetaFile*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMetaFile*)[[[PEXPbMetaFile builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMetaFile*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbMetaFile*)[[[PEXPbMetaFile builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbMetaFile*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbMetaFile*)[[[PEXPbMetaFile builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbMetaFileBuilder*) builder {
  return [[PEXPbMetaFileBuilder alloc] init];
}
+ (PEXPbMetaFileBuilder*) builderWithPrototype:(PEXPbMetaFile*) prototype {
  return [[PEXPbMetaFile builder] mergeFrom:prototype];
}
- (PEXPbMetaFileBuilder*) builder {
  return [PEXPbMetaFile builder];
}
- (PEXPbMetaFileBuilder*) toBuilder {
  return [PEXPbMetaFile builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasTimestamp) {
    [output appendFormat:@"%@%@: %@\n", indent, @"timestamp", [NSNumber numberWithLongLong:self.timestamp]];
  }
  if (self.hasArchiveHash) {
    [output appendFormat:@"%@%@: %@\n", indent, @"archiveHash", self.archiveHash];
  }
  if (self.hasArchiveSig) {
    [output appendFormat:@"%@%@: %@\n", indent, @"archiveSig", self.archiveSig];
  }
  if (self.hasNumberOfFiles) {
    [output appendFormat:@"%@%@: %@\n", indent, @"numberOfFiles", [NSNumber numberWithInteger:self.numberOfFiles]];
  }
  if (self.hasTitle) {
    [output appendFormat:@"%@%@: %@\n", indent, @"title", self.title];
  }
  if (self.hasXdescription) {
    [output appendFormat:@"%@%@: %@\n", indent, @"xdescription", self.xdescription];
  }
  [self.filesArray enumerateObjectsUsingBlock:^(PEXPbMetaFileDetail *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"files"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbMetaFile class]]) {
    return NO;
  }
  PEXPbMetaFile *otherMessage = other;
  return
      self.hasTimestamp == otherMessage.hasTimestamp &&
      (!self.hasTimestamp || self.timestamp == otherMessage.timestamp) &&
      self.hasArchiveHash == otherMessage.hasArchiveHash &&
      (!self.hasArchiveHash || [self.archiveHash isEqual:otherMessage.archiveHash]) &&
      self.hasArchiveSig == otherMessage.hasArchiveSig &&
      (!self.hasArchiveSig || [self.archiveSig isEqual:otherMessage.archiveSig]) &&
      self.hasNumberOfFiles == otherMessage.hasNumberOfFiles &&
      (!self.hasNumberOfFiles || self.numberOfFiles == otherMessage.numberOfFiles) &&
      self.hasTitle == otherMessage.hasTitle &&
      (!self.hasTitle || [self.title isEqual:otherMessage.title]) &&
      self.hasXdescription == otherMessage.hasXdescription &&
      (!self.hasXdescription || [self.xdescription isEqual:otherMessage.xdescription]) &&
      [self.filesArray isEqualToArray:otherMessage.filesArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasTimestamp) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.timestamp] hash];
  }
  if (self.hasArchiveHash) {
    hashCode = hashCode * 31 + [self.archiveHash hash];
  }
  if (self.hasArchiveSig) {
    hashCode = hashCode * 31 + [self.archiveSig hash];
  }
  if (self.hasNumberOfFiles) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.numberOfFiles] hash];
  }
  if (self.hasTitle) {
    hashCode = hashCode * 31 + [self.title hash];
  }
  if (self.hasXdescription) {
    hashCode = hashCode * 31 + [self.xdescription hash];
  }
  [self.filesArray enumerateObjectsUsingBlock:^(PEXPbMetaFileDetail *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface PEXPbMetaFileBuilder()
@property (strong) PEXPbMetaFile* result;
@end

@implementation PEXPbMetaFileBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbMetaFile alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbMetaFileBuilder*) clear {
  self.result = [[PEXPbMetaFile alloc] init];
  return self;
}
- (PEXPbMetaFileBuilder*) clone {
  return [PEXPbMetaFile builderWithPrototype:result];
}
- (PEXPbMetaFile*) defaultInstance {
  return [PEXPbMetaFile defaultInstance];
}
- (PEXPbMetaFile*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbMetaFile*) buildPartial {
  PEXPbMetaFile* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbMetaFileBuilder*) mergeFrom:(PEXPbMetaFile*) other {
  if (other == [PEXPbMetaFile defaultInstance]) {
    return self;
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.hasArchiveHash) {
    [self setArchiveHash:other.archiveHash];
  }
  if (other.hasArchiveSig) {
    [self setArchiveSig:other.archiveSig];
  }
  if (other.hasNumberOfFiles) {
    [self setNumberOfFiles:other.numberOfFiles];
  }
  if (other.hasTitle) {
    [self setTitle:other.title];
  }
  if (other.hasXdescription) {
    [self setXdescription:other.xdescription];
  }
  if (other.filesArray.count > 0) {
    if (result.filesArray == nil) {
      result.filesArray = [[NSMutableArray alloc] initWithArray:other.filesArray];
    } else {
      [result.filesArray addObjectsFromArray:other.filesArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbMetaFileBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbMetaFileBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setTimestamp:[input readUInt64]];
        break;
      }
      case 18: {
        [self setArchiveHash:[input readData]];
        break;
      }
      case 26: {
        [self setArchiveSig:[input readData]];
        break;
      }
      case 32: {
        [self setNumberOfFiles:[input readUInt32]];
        break;
      }
      case 42: {
        [self setTitle:[input readString]];
        break;
      }
      case 50: {
        [self setXdescription:[input readString]];
        break;
      }
      case 58: {
        PEXPbMetaFileDetailBuilder* subBuilder = [PEXPbMetaFileDetail builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFiles:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (UInt64) timestamp {
  return result.timestamp;
}
- (PEXPbMetaFileBuilder*) setTimestamp:(UInt64) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (PEXPbMetaFileBuilder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (BOOL) hasArchiveHash {
  return result.hasArchiveHash;
}
- (NSData*) archiveHash {
  return result.archiveHash;
}
- (PEXPbMetaFileBuilder*) setArchiveHash:(NSData*) value {
  result.hasArchiveHash = YES;
  result.archiveHash = value;
  return self;
}
- (PEXPbMetaFileBuilder*) clearArchiveHash {
  result.hasArchiveHash = NO;
  result.archiveHash = [NSData data];
  return self;
}
- (BOOL) hasArchiveSig {
  return result.hasArchiveSig;
}
- (NSData*) archiveSig {
  return result.archiveSig;
}
- (PEXPbMetaFileBuilder*) setArchiveSig:(NSData*) value {
  result.hasArchiveSig = YES;
  result.archiveSig = value;
  return self;
}
- (PEXPbMetaFileBuilder*) clearArchiveSig {
  result.hasArchiveSig = NO;
  result.archiveSig = [NSData data];
  return self;
}
- (BOOL) hasNumberOfFiles {
  return result.hasNumberOfFiles;
}
- (UInt32) numberOfFiles {
  return result.numberOfFiles;
}
- (PEXPbMetaFileBuilder*) setNumberOfFiles:(UInt32) value {
  result.hasNumberOfFiles = YES;
  result.numberOfFiles = value;
  return self;
}
- (PEXPbMetaFileBuilder*) clearNumberOfFiles {
  result.hasNumberOfFiles = NO;
  result.numberOfFiles = 0;
  return self;
}
- (BOOL) hasTitle {
  return result.hasTitle;
}
- (NSString*) title {
  return result.title;
}
- (PEXPbMetaFileBuilder*) setTitle:(NSString*) value {
  result.hasTitle = YES;
  result.title = value;
  return self;
}
- (PEXPbMetaFileBuilder*) clearTitle {
  result.hasTitle = NO;
  result.title = @"";
  return self;
}
- (BOOL) hasXdescription {
  return result.hasXdescription;
}
- (NSString*) xdescription {
  return result.xdescription;
}
- (PEXPbMetaFileBuilder*) setXdescription:(NSString*) value {
  result.hasXdescription = YES;
  result.xdescription = value;
  return self;
}
- (PEXPbMetaFileBuilder*) clearXdescription {
  result.hasXdescription = NO;
  result.xdescription = @"";
  return self;
}
- (NSMutableArray *)files {
  return result.filesArray;
}
- (PEXPbMetaFileDetail*)filesAtIndex:(NSUInteger)index {
  return [result filesAtIndex:index];
}
- (PEXPbMetaFileBuilder *)addFiles:(PEXPbMetaFileDetail*)value {
  if (result.filesArray == nil) {
    result.filesArray = [[NSMutableArray alloc]init];
  }
  [result.filesArray addObject:value];
  return self;
}
- (PEXPbMetaFileBuilder *)setFilesArray:(NSArray *)array {
  result.filesArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (PEXPbMetaFileBuilder *)clearFiles {
  result.filesArray = nil;
  return self;
}
@end

@interface PEXPbGeneralMsgNotification ()
@property (strong) NSString* title;
@property (strong) NSString* subtitle;
@property UInt64 timestamp;
@property UInt32 nonce;
@property PEXPbGeneralMsgNotificationPEXPbNotificationType notifType;
@property UInt32 notifAux;
@property (strong) NSString* fileTransferNonce;
@property (strong) PBAppendableArray * ackNoncesArray;
@property (strong) NSString* sipCallId;
@property (strong) PBAppendableArray * msgNoncesArray;
@property UInt32 notifCode;
@property UInt32 notifSubCode;
@property (strong) NSString* requestBodyAux;
@end

@implementation PEXPbGeneralMsgNotification

- (BOOL) hasTitle {
  return !!hasTitle_;
}
- (void) setHasTitle:(BOOL) value_ {
  hasTitle_ = !!value_;
}
@synthesize title;
- (BOOL) hasSubtitle {
  return !!hasSubtitle_;
}
- (void) setHasSubtitle:(BOOL) value_ {
  hasSubtitle_ = !!value_;
}
@synthesize subtitle;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) value_ {
  hasTimestamp_ = !!value_;
}
@synthesize timestamp;
- (BOOL) hasNonce {
  return !!hasNonce_;
}
- (void) setHasNonce:(BOOL) value_ {
  hasNonce_ = !!value_;
}
@synthesize nonce;
- (BOOL) hasNotifType {
  return !!hasNotifType_;
}
- (void) setHasNotifType:(BOOL) value_ {
  hasNotifType_ = !!value_;
}
@synthesize notifType;
- (BOOL) hasNotifAux {
  return !!hasNotifAux_;
}
- (void) setHasNotifAux:(BOOL) value_ {
  hasNotifAux_ = !!value_;
}
@synthesize notifAux;
- (BOOL) hasFileTransferNonce {
  return !!hasFileTransferNonce_;
}
- (void) setHasFileTransferNonce:(BOOL) value_ {
  hasFileTransferNonce_ = !!value_;
}
@synthesize fileTransferNonce;
@synthesize ackNoncesArray;
@dynamic ackNonces;
- (BOOL) hasSipCallId {
  return !!hasSipCallId_;
}
- (void) setHasSipCallId:(BOOL) value_ {
  hasSipCallId_ = !!value_;
}
@synthesize sipCallId;
@synthesize msgNoncesArray;
@dynamic msgNonces;
- (BOOL) hasNotifCode {
  return !!hasNotifCode_;
}
- (void) setHasNotifCode:(BOOL) value_ {
  hasNotifCode_ = !!value_;
}
@synthesize notifCode;
- (BOOL) hasNotifSubCode {
  return !!hasNotifSubCode_;
}
- (void) setHasNotifSubCode:(BOOL) value_ {
  hasNotifSubCode_ = !!value_;
}
@synthesize notifSubCode;
- (BOOL) hasRequestBodyAux {
  return !!hasRequestBodyAux_;
}
- (void) setHasRequestBodyAux:(BOOL) value_ {
  hasRequestBodyAux_ = !!value_;
}
@synthesize requestBodyAux;
- (id) init {
  if ((self = [super init])) {
    self.title = @"";
    self.subtitle = @"";
    self.timestamp = 0L;
    self.nonce = 0;
    self.notifType = PEXPbGeneralMsgNotificationPEXPbNotificationTypeNewFile;
    self.notifAux = 0;
    self.fileTransferNonce = @"";
    self.sipCallId = @"";
    self.notifCode = 0;
    self.notifSubCode = 0;
    self.requestBodyAux = @"";
  }
  return self;
}
static PEXPbGeneralMsgNotification* defaultPEXPbGeneralMsgNotificationInstance = nil;
+ (void) initialize {
  if (self == [PEXPbGeneralMsgNotification class]) {
    defaultPEXPbGeneralMsgNotificationInstance = [[PEXPbGeneralMsgNotification alloc] init];
  }
}
+ (PEXPbGeneralMsgNotification*) defaultInstance {
  return defaultPEXPbGeneralMsgNotificationInstance;
}
- (PEXPbGeneralMsgNotification*) defaultInstance {
  return defaultPEXPbGeneralMsgNotificationInstance;
}
- (PBArray *)ackNonces {
  return ackNoncesArray;
}
- (UInt32)ackNoncesAtIndex:(NSUInteger)index {
  return [ackNoncesArray uint32AtIndex:index];
}
- (PBArray *)msgNonces {
  return msgNoncesArray;
}
- (UInt32)msgNoncesAtIndex:(NSUInteger)index {
  return [msgNoncesArray uint32AtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasTitle) {
    [output writeString:1 value:self.title];
  }
  if (self.hasSubtitle) {
    [output writeString:2 value:self.subtitle];
  }
  if (self.hasFileTransferNonce) {
    [output writeString:3 value:self.fileTransferNonce];
  }
  if (self.hasTimestamp) {
    [output writeUInt64:4 value:self.timestamp];
  }
  if (self.hasNotifType) {
    [output writeEnum:5 value:self.notifType];
  }
  if (self.hasNonce) {
    [output writeUInt32:6 value:self.nonce];
  }
  const NSUInteger ackNoncesArrayCount = self.ackNoncesArray.count;
  if (ackNoncesArrayCount > 0) {
    const UInt32 *values = (const UInt32 *)self.ackNoncesArray.data;
    [output writeRawVarint32:58];
    [output writeRawVarint32:ackNoncesMemoizedSerializedSize];
    for (NSUInteger i = 0; i < ackNoncesArrayCount; ++i) {
      [output writeUInt32NoTag:values[i]];
    }
  }
  if (self.hasNotifAux) {
    [output writeUInt32:8 value:self.notifAux];
  }
  if (self.hasSipCallId) {
    [output writeString:9 value:self.sipCallId];
  }
  const NSUInteger msgNoncesArrayCount = self.msgNoncesArray.count;
  if (msgNoncesArrayCount > 0) {
    const UInt32 *values = (const UInt32 *)self.msgNoncesArray.data;
    for (NSUInteger i = 0; i < msgNoncesArrayCount; ++i) {
      [output writeUInt32:11 value:values[i]];
    }
  }
  if (self.hasNotifCode) {
    [output writeUInt32:15 value:self.notifCode];
  }
  if (self.hasNotifSubCode) {
    [output writeUInt32:16 value:self.notifSubCode];
  }
  if (self.hasRequestBodyAux) {
    [output writeString:20 value:self.requestBodyAux];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasTitle) {
    size_ += computeStringSize(1, self.title);
  }
  if (self.hasSubtitle) {
    size_ += computeStringSize(2, self.subtitle);
  }
  if (self.hasFileTransferNonce) {
    size_ += computeStringSize(3, self.fileTransferNonce);
  }
  if (self.hasTimestamp) {
    size_ += computeUInt64Size(4, self.timestamp);
  }
  if (self.hasNotifType) {
    size_ += computeEnumSize(5, self.notifType);
  }
  if (self.hasNonce) {
    size_ += computeUInt32Size(6, self.nonce);
  }
  {
    __block SInt32 dataSize = 0;
    const NSUInteger count = self.ackNoncesArray.count;
    const UInt32 *values = (const UInt32 *)self.ackNoncesArray.data;
    for (NSUInteger i = 0; i < count; ++i) {
      dataSize += computeUInt32SizeNoTag(values[i]);
    }
    size_ += dataSize;
    if (count > 0) {
      size_ += 1;
      size_ += computeInt32SizeNoTag(dataSize);
    }
    ackNoncesMemoizedSerializedSize = dataSize;
  }
  if (self.hasNotifAux) {
    size_ += computeUInt32Size(8, self.notifAux);
  }
  if (self.hasSipCallId) {
    size_ += computeStringSize(9, self.sipCallId);
  }
  {
    __block SInt32 dataSize = 0;
    const NSUInteger count = self.msgNoncesArray.count;
    const UInt32 *values = (const UInt32 *)self.msgNoncesArray.data;
    for (NSUInteger i = 0; i < count; ++i) {
      dataSize += computeUInt32SizeNoTag(values[i]);
    }
    size_ += dataSize;
    size_ += (SInt32)(1 * count);
  }
  if (self.hasNotifCode) {
    size_ += computeUInt32Size(15, self.notifCode);
  }
  if (self.hasNotifSubCode) {
    size_ += computeUInt32Size(16, self.notifSubCode);
  }
  if (self.hasRequestBodyAux) {
    size_ += computeStringSize(20, self.requestBodyAux);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (PEXPbGeneralMsgNotification*) parseFromData:(NSData*) data {
  return (PEXPbGeneralMsgNotification*)[[[PEXPbGeneralMsgNotification builder] mergeFromData:data] build];
}
+ (PEXPbGeneralMsgNotification*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbGeneralMsgNotification*)[[[PEXPbGeneralMsgNotification builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PEXPbGeneralMsgNotification*) parseFromInputStream:(NSInputStream*) input {
  return (PEXPbGeneralMsgNotification*)[[[PEXPbGeneralMsgNotification builder] mergeFromInputStream:input] build];
}
+ (PEXPbGeneralMsgNotification*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbGeneralMsgNotification*)[[[PEXPbGeneralMsgNotification builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbGeneralMsgNotification*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PEXPbGeneralMsgNotification*)[[[PEXPbGeneralMsgNotification builder] mergeFromCodedInputStream:input] build];
}
+ (PEXPbGeneralMsgNotification*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PEXPbGeneralMsgNotification*)[[[PEXPbGeneralMsgNotification builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PEXPbGeneralMsgNotificationBuilder*) builder {
  return [[PEXPbGeneralMsgNotificationBuilder alloc] init];
}
+ (PEXPbGeneralMsgNotificationBuilder*) builderWithPrototype:(PEXPbGeneralMsgNotification*) prototype {
  return [[PEXPbGeneralMsgNotification builder] mergeFrom:prototype];
}
- (PEXPbGeneralMsgNotificationBuilder*) builder {
  return [PEXPbGeneralMsgNotification builder];
}
- (PEXPbGeneralMsgNotificationBuilder*) toBuilder {
  return [PEXPbGeneralMsgNotification builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasTitle) {
    [output appendFormat:@"%@%@: %@\n", indent, @"title", self.title];
  }
  if (self.hasSubtitle) {
    [output appendFormat:@"%@%@: %@\n", indent, @"subtitle", self.subtitle];
  }
  if (self.hasFileTransferNonce) {
    [output appendFormat:@"%@%@: %@\n", indent, @"fileTransferNonce", self.fileTransferNonce];
  }
  if (self.hasTimestamp) {
    [output appendFormat:@"%@%@: %@\n", indent, @"timestamp", [NSNumber numberWithLongLong:self.timestamp]];
  }
  if (self.hasNotifType) {
    [output appendFormat:@"%@%@: %@\n", indent, @"notifType", [NSNumber numberWithInteger:self.notifType]];
  }
  if (self.hasNonce) {
    [output appendFormat:@"%@%@: %@\n", indent, @"nonce", [NSNumber numberWithInteger:self.nonce]];
  }
  [self.ackNoncesArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@: %@\n", indent, @"ackNonces", obj];
  }];
  if (self.hasNotifAux) {
    [output appendFormat:@"%@%@: %@\n", indent, @"notifAux", [NSNumber numberWithInteger:self.notifAux]];
  }
  if (self.hasSipCallId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sipCallId", self.sipCallId];
  }
  [self.msgNoncesArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@: %@\n", indent, @"msgNonces", obj];
  }];
  if (self.hasNotifCode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"notifCode", [NSNumber numberWithInteger:self.notifCode]];
  }
  if (self.hasNotifSubCode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"notifSubCode", [NSNumber numberWithInteger:self.notifSubCode]];
  }
  if (self.hasRequestBodyAux) {
    [output appendFormat:@"%@%@: %@\n", indent, @"requestBodyAux", self.requestBodyAux];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[PEXPbGeneralMsgNotification class]]) {
    return NO;
  }
  PEXPbGeneralMsgNotification *otherMessage = other;
  return
      self.hasTitle == otherMessage.hasTitle &&
      (!self.hasTitle || [self.title isEqual:otherMessage.title]) &&
      self.hasSubtitle == otherMessage.hasSubtitle &&
      (!self.hasSubtitle || [self.subtitle isEqual:otherMessage.subtitle]) &&
      self.hasFileTransferNonce == otherMessage.hasFileTransferNonce &&
      (!self.hasFileTransferNonce || [self.fileTransferNonce isEqual:otherMessage.fileTransferNonce]) &&
      self.hasTimestamp == otherMessage.hasTimestamp &&
      (!self.hasTimestamp || self.timestamp == otherMessage.timestamp) &&
      self.hasNotifType == otherMessage.hasNotifType &&
      (!self.hasNotifType || self.notifType == otherMessage.notifType) &&
      self.hasNonce == otherMessage.hasNonce &&
      (!self.hasNonce || self.nonce == otherMessage.nonce) &&
      [self.ackNoncesArray isEqualToArray:otherMessage.ackNoncesArray] &&
      self.hasNotifAux == otherMessage.hasNotifAux &&
      (!self.hasNotifAux || self.notifAux == otherMessage.notifAux) &&
      self.hasSipCallId == otherMessage.hasSipCallId &&
      (!self.hasSipCallId || [self.sipCallId isEqual:otherMessage.sipCallId]) &&
      [self.msgNoncesArray isEqualToArray:otherMessage.msgNoncesArray] &&
      self.hasNotifCode == otherMessage.hasNotifCode &&
      (!self.hasNotifCode || self.notifCode == otherMessage.notifCode) &&
      self.hasNotifSubCode == otherMessage.hasNotifSubCode &&
      (!self.hasNotifSubCode || self.notifSubCode == otherMessage.notifSubCode) &&
      self.hasRequestBodyAux == otherMessage.hasRequestBodyAux &&
      (!self.hasRequestBodyAux || [self.requestBodyAux isEqual:otherMessage.requestBodyAux]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasTitle) {
    hashCode = hashCode * 31 + [self.title hash];
  }
  if (self.hasSubtitle) {
    hashCode = hashCode * 31 + [self.subtitle hash];
  }
  if (self.hasFileTransferNonce) {
    hashCode = hashCode * 31 + [self.fileTransferNonce hash];
  }
  if (self.hasTimestamp) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.timestamp] hash];
  }
  if (self.hasNotifType) {
    hashCode = hashCode * 31 + self.notifType;
  }
  if (self.hasNonce) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.nonce] hash];
  }
  [self.ackNoncesArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [obj longValue];
  }];
  if (self.hasNotifAux) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.notifAux] hash];
  }
  if (self.hasSipCallId) {
    hashCode = hashCode * 31 + [self.sipCallId hash];
  }
  [self.msgNoncesArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [obj longValue];
  }];
  if (self.hasNotifCode) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.notifCode] hash];
  }
  if (self.hasNotifSubCode) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.notifSubCode] hash];
  }
  if (self.hasRequestBodyAux) {
    hashCode = hashCode * 31 + [self.requestBodyAux hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL PEXPbGeneralMsgNotificationPEXPbNotificationTypeIsValidValue(PEXPbGeneralMsgNotificationPEXPbNotificationType value) {
  switch (value) {
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeNewFile:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeMissedCall:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeDhKeySyncRequest:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeFullMailbox:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeMessageReadAck:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeCallMeRequest:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeBurnMessage:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeConversationPolicy:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeCertRequest:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeIseeYorCertificate:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypePairingRequest:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeContactList:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeGroupChat:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeGroupCall:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeGroupKey:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeServerRequest:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeGeneralRequest:
    case PEXPbGeneralMsgNotificationPEXPbNotificationTypeOther:
      return YES;
    default:
      return NO;
  }
}
@interface PEXPbGeneralMsgNotificationBuilder()
@property (strong) PEXPbGeneralMsgNotification* result;
@end

@implementation PEXPbGeneralMsgNotificationBuilder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[PEXPbGeneralMsgNotification alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PEXPbGeneralMsgNotificationBuilder*) clear {
  self.result = [[PEXPbGeneralMsgNotification alloc] init];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clone {
  return [PEXPbGeneralMsgNotification builderWithPrototype:result];
}
- (PEXPbGeneralMsgNotification*) defaultInstance {
  return [PEXPbGeneralMsgNotification defaultInstance];
}
- (PEXPbGeneralMsgNotification*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PEXPbGeneralMsgNotification*) buildPartial {
  PEXPbGeneralMsgNotification* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (PEXPbGeneralMsgNotificationBuilder*) mergeFrom:(PEXPbGeneralMsgNotification*) other {
  if (other == [PEXPbGeneralMsgNotification defaultInstance]) {
    return self;
  }
  if (other.hasTitle) {
    [self setTitle:other.title];
  }
  if (other.hasSubtitle) {
    [self setSubtitle:other.subtitle];
  }
  if (other.hasTimestamp) {
    [self setTimestamp:other.timestamp];
  }
  if (other.hasNonce) {
    [self setNonce:other.nonce];
  }
  if (other.hasNotifType) {
    [self setNotifType:other.notifType];
  }
  if (other.hasNotifAux) {
    [self setNotifAux:other.notifAux];
  }
  if (other.hasFileTransferNonce) {
    [self setFileTransferNonce:other.fileTransferNonce];
  }
  if (other.ackNoncesArray.count > 0) {
    if (result.ackNoncesArray == nil) {
      result.ackNoncesArray = [other.ackNoncesArray copy];
    } else {
      [result.ackNoncesArray appendArray:other.ackNoncesArray];
    }
  }
  if (other.hasSipCallId) {
    [self setSipCallId:other.sipCallId];
  }
  if (other.msgNoncesArray.count > 0) {
    if (result.msgNoncesArray == nil) {
      result.msgNoncesArray = [other.msgNoncesArray copy];
    } else {
      [result.msgNoncesArray appendArray:other.msgNoncesArray];
    }
  }
  if (other.hasNotifCode) {
    [self setNotifCode:other.notifCode];
  }
  if (other.hasNotifSubCode) {
    [self setNotifSubCode:other.notifSubCode];
  }
  if (other.hasRequestBodyAux) {
    [self setRequestBodyAux:other.requestBodyAux];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PEXPbGeneralMsgNotificationBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setTitle:[input readString]];
        break;
      }
      case 18: {
        [self setSubtitle:[input readString]];
        break;
      }
      case 26: {
        [self setFileTransferNonce:[input readString]];
        break;
      }
      case 32: {
        [self setTimestamp:[input readUInt64]];
        break;
      }
      case 40: {
        PEXPbGeneralMsgNotificationPEXPbNotificationType value = (PEXPbGeneralMsgNotificationPEXPbNotificationType)[input readEnum];
        if (PEXPbGeneralMsgNotificationPEXPbNotificationTypeIsValidValue(value)) {
          [self setNotifType:value];
        } else {
          [unknownFields mergeVarintField:5 value:value];
        }
        break;
      }
      case 48: {
        [self setNonce:[input readUInt32]];
        break;
      }
      case 58: {
        SInt32 length = [input readRawVarint32];
        SInt32 limit = [input pushLimit:length];
        if (result.ackNoncesArray == nil) {
          result.ackNoncesArray = [PBAppendableArray arrayWithValueType:PBArrayValueTypeUInt32];
        }
        while (input.bytesUntilLimit > 0) {
          [result.ackNoncesArray addUint32:[input readUInt32]];
        }
        [input popLimit:limit];
        break;
      }
      case 64: {
        [self setNotifAux:[input readUInt32]];
        break;
      }
      case 74: {
        [self setSipCallId:[input readString]];
        break;
      }
      case 88: {
        [self addMsgNonces:[input readUInt32]];
        break;
      }
      case 120: {
        [self setNotifCode:[input readUInt32]];
        break;
      }
      case 128: {
        [self setNotifSubCode:[input readUInt32]];
        break;
      }
      case 162: {
        [self setRequestBodyAux:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasTitle {
  return result.hasTitle;
}
- (NSString*) title {
  return result.title;
}
- (PEXPbGeneralMsgNotificationBuilder*) setTitle:(NSString*) value {
  result.hasTitle = YES;
  result.title = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearTitle {
  result.hasTitle = NO;
  result.title = @"";
  return self;
}
- (BOOL) hasSubtitle {
  return result.hasSubtitle;
}
- (NSString*) subtitle {
  return result.subtitle;
}
- (PEXPbGeneralMsgNotificationBuilder*) setSubtitle:(NSString*) value {
  result.hasSubtitle = YES;
  result.subtitle = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearSubtitle {
  result.hasSubtitle = NO;
  result.subtitle = @"";
  return self;
}
- (BOOL) hasTimestamp {
  return result.hasTimestamp;
}
- (UInt64) timestamp {
  return result.timestamp;
}
- (PEXPbGeneralMsgNotificationBuilder*) setTimestamp:(UInt64) value {
  result.hasTimestamp = YES;
  result.timestamp = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearTimestamp {
  result.hasTimestamp = NO;
  result.timestamp = 0L;
  return self;
}
- (BOOL) hasNonce {
  return result.hasNonce;
}
- (UInt32) nonce {
  return result.nonce;
}
- (PEXPbGeneralMsgNotificationBuilder*) setNonce:(UInt32) value {
  result.hasNonce = YES;
  result.nonce = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearNonce {
  result.hasNonce = NO;
  result.nonce = 0;
  return self;
}
- (BOOL) hasNotifType {
  return result.hasNotifType;
}
- (PEXPbGeneralMsgNotificationPEXPbNotificationType) notifType {
  return result.notifType;
}
- (PEXPbGeneralMsgNotificationBuilder*) setNotifType:(PEXPbGeneralMsgNotificationPEXPbNotificationType) value {
  result.hasNotifType = YES;
  result.notifType = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearNotifType {
  result.hasNotifType = NO;
  result.notifType = PEXPbGeneralMsgNotificationPEXPbNotificationTypeNewFile;
  return self;
}
- (BOOL) hasNotifAux {
  return result.hasNotifAux;
}
- (UInt32) notifAux {
  return result.notifAux;
}
- (PEXPbGeneralMsgNotificationBuilder*) setNotifAux:(UInt32) value {
  result.hasNotifAux = YES;
  result.notifAux = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearNotifAux {
  result.hasNotifAux = NO;
  result.notifAux = 0;
  return self;
}
- (BOOL) hasFileTransferNonce {
  return result.hasFileTransferNonce;
}
- (NSString*) fileTransferNonce {
  return result.fileTransferNonce;
}
- (PEXPbGeneralMsgNotificationBuilder*) setFileTransferNonce:(NSString*) value {
  result.hasFileTransferNonce = YES;
  result.fileTransferNonce = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearFileTransferNonce {
  result.hasFileTransferNonce = NO;
  result.fileTransferNonce = @"";
  return self;
}
- (PBAppendableArray *)ackNonces {
  return result.ackNoncesArray;
}
- (UInt32)ackNoncesAtIndex:(NSUInteger)index {
  return [result ackNoncesAtIndex:index];
}
- (PEXPbGeneralMsgNotificationBuilder *)addAckNonces:(UInt32)value {
  if (result.ackNoncesArray == nil) {
    result.ackNoncesArray = [PBAppendableArray arrayWithValueType:PBArrayValueTypeUInt32];
  }
  [result.ackNoncesArray addUint32:value];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder *)setAckNoncesArray:(NSArray *)array {
  result.ackNoncesArray = [PBAppendableArray arrayWithArray:array valueType:PBArrayValueTypeUInt32];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder *)setAckNoncesValues:(const UInt32 *)values count:(NSUInteger)count {
  result.ackNoncesArray = [PBAppendableArray arrayWithValues:values count:count valueType:PBArrayValueTypeUInt32];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder *)clearAckNonces {
  result.ackNoncesArray = nil;
  return self;
}
- (BOOL) hasSipCallId {
  return result.hasSipCallId;
}
- (NSString*) sipCallId {
  return result.sipCallId;
}
- (PEXPbGeneralMsgNotificationBuilder*) setSipCallId:(NSString*) value {
  result.hasSipCallId = YES;
  result.sipCallId = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearSipCallId {
  result.hasSipCallId = NO;
  result.sipCallId = @"";
  return self;
}
- (PBAppendableArray *)msgNonces {
  return result.msgNoncesArray;
}
- (UInt32)msgNoncesAtIndex:(NSUInteger)index {
  return [result msgNoncesAtIndex:index];
}
- (PEXPbGeneralMsgNotificationBuilder *)addMsgNonces:(UInt32)value {
  if (result.msgNoncesArray == nil) {
    result.msgNoncesArray = [PBAppendableArray arrayWithValueType:PBArrayValueTypeUInt32];
  }
  [result.msgNoncesArray addUint32:value];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder *)setMsgNoncesArray:(NSArray *)array {
  result.msgNoncesArray = [PBAppendableArray arrayWithArray:array valueType:PBArrayValueTypeUInt32];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder *)setMsgNoncesValues:(const UInt32 *)values count:(NSUInteger)count {
  result.msgNoncesArray = [PBAppendableArray arrayWithValues:values count:count valueType:PBArrayValueTypeUInt32];
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder *)clearMsgNonces {
  result.msgNoncesArray = nil;
  return self;
}
- (BOOL) hasNotifCode {
  return result.hasNotifCode;
}
- (UInt32) notifCode {
  return result.notifCode;
}
- (PEXPbGeneralMsgNotificationBuilder*) setNotifCode:(UInt32) value {
  result.hasNotifCode = YES;
  result.notifCode = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearNotifCode {
  result.hasNotifCode = NO;
  result.notifCode = 0;
  return self;
}
- (BOOL) hasNotifSubCode {
  return result.hasNotifSubCode;
}
- (UInt32) notifSubCode {
  return result.notifSubCode;
}
- (PEXPbGeneralMsgNotificationBuilder*) setNotifSubCode:(UInt32) value {
  result.hasNotifSubCode = YES;
  result.notifSubCode = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearNotifSubCode {
  result.hasNotifSubCode = NO;
  result.notifSubCode = 0;
  return self;
}
- (BOOL) hasRequestBodyAux {
  return result.hasRequestBodyAux;
}
- (NSString*) requestBodyAux {
  return result.requestBodyAux;
}
- (PEXPbGeneralMsgNotificationBuilder*) setRequestBodyAux:(NSString*) value {
  result.hasRequestBodyAux = YES;
  result.requestBodyAux = value;
  return self;
}
- (PEXPbGeneralMsgNotificationBuilder*) clearRequestBodyAux {
  result.hasRequestBodyAux = NO;
  result.requestBodyAux = @"";
  return self;
}
@end


// @@protoc_insertion_point(global_scope)
